#!/usr/bin/env python

# send-client-email
# ----------------------------------------------------------------------------
# Copyright (c) 2007 Colin Guthrie
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
#   The above copyright notice and this permission notice shall be included in
#   all copies or substantial portions of the Software. 
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
# ----------------------------------------------------------------------------

# This email integration script is meant to interface to the Trac
# (http://www.edgewall.com/products/trac/) issue tracking/wiki/etc
# system


import re
import os
import sys
import locale
import time
from lxml import etree
import codecs
from datetime import datetime
from optparse import OptionParser
from StringIO import StringIO

from trac import __version__
from trac.core import *
from trac.env import open_environment
from trac.util.datefmt import format_date, to_datetime
from trac.wiki import wiki_to_html
from genshi import escape


parser = OptionParser()
depr = '(not used anymore)'
parser.add_option('-e', '--env', dest='envpath',
                  help='Required. Path to the Trac environment.')
parser.add_option('-p', '--period', dest='period',
                  help='Period string as specified in the configuration of notifications. Defaults to "daily"')
parser.add_option('-t', '--type', dest='mailtype',
                  choices=['summary','changes'],
                  help='The type of email. Can be either "summary" (default) or "changes".')
parser.add_option('-x', '--xslt', dest='xslt',
                  help='The XSLT used to convert the change information to an email (optional, will use "MAILTYPE.xslt" from the current folder).')
parser.add_option('-d', action='store_true', dest='debug',
                  help='Turn on debug mode - does not update database and prints verbose messages.')
parser.add_option('-m', '--mail', dest='mail',
                  help='Email override. Useful in combination with -d.')
parser.set_defaults(period='daily', mailtype='summary')
(options, args) = parser.parse_args(sys.argv[1:])


class SendClientMailer(object):
  def __init__(self, env):
    self.env = env
    self.config = env.config
    self.encoding = 'utf-8'
  
  def Send(self, subject, addresses, xml, transform):
    if not self.config.getbool('notification', 'smtp_enabled'):
      return
    smtp_server = self.config['notification'].get('smtp_server')
    smtp_port = self.config['notification'].getint('smtp_port')
    from_email = self.config['notification'].get('smtp_from')
    from_name = self.config['notification'].get('smtp_from_name')
    replyto_email = self.config['notification'].get('smtp_replyto')
    from_email = from_email or replyto_email
    if not from_email:
      return
    
    # Authentication info (optional)
    user_name = self.config['notification'].get('smtp_user')
    password = self.config['notification'].get('smtp_password')
    
    # Thanks to the author of this recipe:
    # http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/473810
    
    from email.MIMEMultipart import MIMEMultipart
    from email.MIMEText import MIMEText
    from email.MIMEImage import MIMEImage
    from email.Charset import add_charset, SHORTEST
    add_charset( 'utf-8', SHORTEST, None, None )

    projname = self.config.get('project', 'name')
    
    # Create the root message and fill in the from, to, and subject headers
    msg_root = MIMEMultipart('alternative')
    msg_root['To'] = str(', ').join(addresses)
    
    msg_root['X-Mailer'] = 'ClientsPlugin for Trac'
    msg_root['X-Trac-Version'] =  __version__
    msg_root['X-Trac-Project'] =  projname
    msg_root['Precedence'] = 'bulk'
    msg_root['Auto-Submitted'] = 'auto-generated'
    msg_root['Subject'] = subject
    msg_root['From'] = '%s <%s>' % (from_name or projname, from_email)
    msg_root['Reply-To'] = replyto_email
    msg_root.preamble = 'This is a multi-part message in MIME format.'
    
    view = 'plain'
    arg = "'%s'" % view
    result = transform(xml, view=arg)
    msg_text = MIMEText(str(result), view, self.encoding)
    msg_root.attach(msg_text)
    
    msg_related = MIMEMultipart('related')
    msg_root.attach(msg_related)
    
    view = 'html'
    arg = "'%s'" % view
    result = transform(xml, view=arg)
    #file = open('/tmp/send-client-email.html', 'w')
    #file.write(str(result))
    #file.close()

    msg_text = MIMEText(str(result), view, self.encoding)
    msg_related.attach(msg_text)
    
    # Handle image embedding...
    view = 'images'
    arg = "'%s'" % view
    result = transform(xml, view=arg)
    if result:
      images = result.getroot()
      if images:
        for img in images:
          if 'img' != img.tag:
            continue
          if not img.get('id') or not img.get('src'):
            continue
          
          fp = open(img.get('src'), 'rb')
          if not fp:
            continue
          msg_img = MIMEImage(fp.read())
          fp.close()
          msg_img.add_header('Content-ID', '<%s>' % img.get('id'))
          msg_related.attach(msg_img)
    
    # Send the email
    import smtplib
    smtp = smtplib.SMTP() #smtp_server, smtp_port)
    if False and user_name:
        smtp.login(user_name, password)
    smtp.connect()
    smtp.sendmail(from_email, addresses, msg_root.as_string())
    smtp.quit()


class SendClientFakeReq:
  def __init__(self):
    class SendClientFakeHref:
      def __call__(self, *args, **keywords):
        return ''
      def wiki(self, *args, **keywords):
        return ''
      def ticket(self, num):
        return '#%d' % (num)
    self.href = SendClientFakeHref()
    self.abs_href = SendClientFakeHref()
    self.perm = []
  
  def __call__(self, *args, **keywords):
    return ''
  def perm(self, *args, **keywords):
    return []

class SendClientEmails:

    def __init__(self):
        def myformat_date(dte):
          if dte:
            return format_date(dte, '%e %b %Y')
          return 'No date set'
        def myformat_hours(hrs):
          from math import floor
          if hrs:
            hrs = float(hrs)
            if 0 != hrs:
              neg = False
              if hrs < 0:
                neg = True
                hours *= -1
              mins = floor((hrs - floor(hrs)) * 60)
              str = ''
              if neg:
                str = '-'
              if hrs:
                str = "%s%sh" % (str, int(floor(hrs)))
              if mins:
                str = "%s %sm" % (str, int(mins))
              return str;
          return 'No estimate available'
        
        locale.setlocale(locale.LC_ALL, '')
        self.env = open_environment(options.envpath)
        self.req = SendClientFakeReq()
        from clients.processor import extract_client_text

        # Sync the repo so that any commits that happen to have been made
        # that include client comments are included.
        repos = self.env.get_repository()
        repos.sync()
        
        field = 'summary'
        if 'changes' == options.mailtype:
          field = 'changes'
        
        stylesheet = '%s.xslt' % options.mailtype
        if options.xslt:
          stylesheet = options.xslt
        
        try:
          ss = open(stylesheet, 'r')
          transform = etree.XSLT(etree.parse(ss))
        except:
          print "Error: Cannot load/parse stylesheet '%s'" % stylesheet
          exit(1)
          
        
        sql = ("SELECT name, %s_list, %s_lastupdate "
               "FROM client "
               "WHERE %s_period=" % (field, field, field)) + "%s"
        
        now = int(time.time())
        mailer = SendClientMailer(self.env)
        db = self.env.get_db_cnx()
        cursor = db.cursor()
        cursor.execute(sql, (options.period,))
        for name, emaillist, lastupdate in cursor:
          if options.debug:
            print "Processing client '%s'" % name
          
          # Don't clobber clients with historical updates
          if not lastupdate:
              # Update the date field and forget about this run.
              sql = ("UPDATE client SET %s_lastupdate" % field) + \
                     "=%s WHERE name=%s"
              cursor2 = db.cursor()
              cursor2.execute(sql, (now, name))
              continue
          
          emails = []
          for email in emaillist.replace(',', ' ').split(' '):
            if '' != email.strip():
              emails.append(email.strip())

          if options.mail:
            if options.debug:
              print "  Overriding emails ('%s') to '%s'" % (emaillist, options.mail)
            emails = []
            emails.append(options.mail)

          if not emails:
            # No emails, so no where to send it.
            if options.debug:
              print "  No email addresses registered. Skipping."
            continue

          summeriser = None
          if 'summary' == field:
            from clients.summary_milestone import ClientMilestoneSummary
            summariser = ClientMilestoneSummary(self.env)
          else:
            from clients.summary_ticketchanges import ClientTicketChanges
            summariser = ClientTicketChanges(self.env)

          if not summariser.init("instancedummy", name):
            continue

          xml = summariser.get_summary(self.req, lastupdate, now)
          if xml is None:
            continue

          subject = 'Ticket Summary for %s' % name
          if 'changes' == field:
            subject = 'Ticket Change Summary for %s' % name
          if options.debug:
            print "  Sending email '%s'" % subject
          mailer.Send(subject, emails, xml, transform)

          if not options.debug:
            # Update the date field
            sql = ("UPDATE client SET %s_lastupdate" % field) + \
                   "=%s WHERE name=%s"
            cursor2 = db.cursor()
            cursor2.execute(sql, (now, name))
          
        db.commit()
        db.close()

if __name__ == "__main__":
    if not options.envpath:
        print "For usage: %s --help" % (sys.argv[0])
    else:
        SendClientEmails()
