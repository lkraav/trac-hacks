#!/usr/bin/env python

# send-client-email
# ----------------------------------------------------------------------------
# Copyright (c) 2007 Colin Guthrie
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
#   The above copyright notice and this permission notice shall be included in
#   all copies or substantial portions of the Software. 
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
# ----------------------------------------------------------------------------

# This email integration script is meant to interface to the Trac
# (http://www.edgewall.com/products/trac/) issue tracking/wiki/etc
# system


import re
import os
import sys
import locale
import time
from lxml import etree
import codecs
from datetime import datetime
from optparse import OptionParser
from StringIO import StringIO

from trac import __version__
from trac.core import *
from trac.env import open_environment
from trac.util.datefmt import format_date, to_datetime
from trac.wiki import wiki_to_html
from genshi import escape


parser = OptionParser()
depr = '(not used anymore)'
parser.add_option('-e', '--env', dest='envpath',
                  help='Required. Path to the Trac environment.')
parser.add_option('-p', '--period', dest='period',
                  help='Period string as specified in the configuration of notifications. Defaults to "daily"')
parser.add_option('-t', '--type', dest='mailtype',
                  choices=['summary','changes'],
                  help='The type of email. Can be either "summary" (default) or "changes".')
parser.add_option('-x', '--xslt', dest='xslt',
                  help='The XSLT used to convert the change information to an email (optional, will use "MAILTYPE.xslt" from the current folder).')
parser.add_option('-d', action='store_true', dest='debug',
                  help='Turn on debug mode - does not update database and prints verbose messages.')
parser.add_option('-m', '--mail', dest='mail',
                  help='Email override. Useful in combination with -d.')
parser.set_defaults(period='daily', mailtype='summary')
(options, args) = parser.parse_args(sys.argv[1:])


class SendClientMailer(object):
  def __init__(self, env):
    self.env = env
    self.config = env.config
    self.encoding = 'us-ascii'
  
  def Send(self, subject, addresses, xml, transform):
    if not self.config.getbool('notification', 'smtp_enabled'):
      return
    smtp_server = self.config['notification'].get('smtp_server')
    smtp_port = self.config['notification'].getint('smtp_port')
    from_email = self.config['notification'].get('smtp_from')
    from_name = self.config['notification'].get('smtp_from_name')
    replyto_email = self.config['notification'].get('smtp_replyto')
    from_email = from_email or replyto_email
    if not from_email:
      return
    
    # Authentication info (optional)
    user_name = self.config['notification'].get('smtp_user')
    password = self.config['notification'].get('smtp_password')
    
    # Thanks to the author of this recipe:
    # http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/473810
    
    from email.MIMEMultipart import MIMEMultipart
    from email.MIMEText import MIMEText
    from email.MIMEImage import MIMEImage
    
    projname = self.config.get('project', 'name')
    
    # Create the root message and fill in the from, to, and subject headers
    msg_root = MIMEMultipart('alternative')
    msg_root['To'] = str(', ').join(addresses)
    
    msg_root['X-Mailer'] = 'ClientsPlugin for Trac'
    msg_root['X-Trac-Version'] =  __version__
    msg_root['X-Trac-Project'] =  projname
    msg_root['Precedence'] = 'bulk'
    msg_root['Auto-Submitted'] = 'auto-generated'
    msg_root['Subject'] = subject
    msg_root['From'] = '%s <%s>' % (from_name or projname, from_email)
    msg_root['Reply-To'] = replyto_email
    msg_root.preamble = 'This is a multi-part message in MIME format.'
    
    view = 'plain'
    arg = "'%s'" % view
    result = transform(xml, view=arg)
    msg_text = MIMEText(str(result), view, self.encoding)
    msg_root.attach(msg_text)
    
    msg_related = MIMEMultipart('related')
    msg_root.attach(msg_related)
    
    view = 'html'
    arg = "'%s'" % view
    result = transform(xml, view=arg)
    msg_text = MIMEText(str(result), view, self.encoding)
    msg_related.attach(msg_text)
    
    # Handle image embedding...
    view = 'images'
    arg = "'%s'" % view
    result = transform(xml, view=arg)
    if result:
      for img in result.getroot():
        if 'img' != img.tag:
          continue
        if not img.get('id') or not img.get('src'):
          continue
        
        fp = open(img.get('src'), 'rb')
        if not fp:
          continue
        msg_img = MIMEImage(fp.read())
        fp.close()
        msg_img.add_header('Content-ID', '<%s>' % img.get('id'))
        msg_related.attach(msg_img)
    
    # Send the email
    import smtplib
    smtp = smtplib.SMTP() #smtp_server, smtp_port)
    if False and user_name:
        smtp.login(user_name, password)
    smtp.connect()
    smtp.sendmail(from_email, addresses, msg_root.as_string())
    smtp.quit()


class SendClientFakeReq:
  def __init__(self):
    class SendClientFakeHref:
      def __call__(self, *args, **keywords):
        return ''
      def wiki(self, *args, **keywords):
        return ''
    self.href = SendClientFakeHref()
    self.abs_href = SendClientFakeHref()
  
  def perm(self, *args, **keywords):
    return []

    return SendClientFakeWiki()

class SendClientEmails:

    def __init__(self):
        def myformat_date(dte):
          if dte:
            return format_date(dte, '%e %b %Y')
          return 'No date set'
        
        locale.setlocale(locale.LC_ALL, '')
        self.env = open_environment(options.envpath)
        self.req = SendClientFakeReq()
        from clients.processor import extract_client_text

        # Sync the repo so that any commits that happen to have been made
        # that include client comments are included.
        repos = self.env.get_repository()
        repos.sync()
        
        field = 'summary'
        if 'changes' == options.mailtype:
          field = 'changes'
        
        stylesheet = '%s.xslt' % options.mailtype
        if options.xslt:
          stylesheet = options.xslt
        
        try:
          ss = open(stylesheet, 'r')
          transform = etree.XSLT(etree.parse(ss))
        except:
          print "Error: Cannot load/parse stylesheet '%s'" % stylesheet
          exit(1)
          
        
        sql = ("SELECT name, %s_list, %s_lastupdate "
               "FROM client "
               "WHERE %s_period=" % (field, field, field)) + "%s"
        
        now = int(time.time())
        mailer = SendClientMailer(self.env)
        db = self.env.get_db_cnx()
        cursor = db.cursor()
        cursor.execute(sql, (options.period,))
        for name, emaillist, lastupdate in cursor:
          if options.debug:
            print "Processing client '%s'" % name
          
          # Don't clobber clients with historical updates
          if not lastupdate:
              # Update the date field and forget about this run.
              sql = ("UPDATE client SET %s_lastupdate" % field) + \
                     "=%s WHERE name=%s"
              cursor2 = db.cursor()
              cursor2.execute(sql, (now, name))
              continue
          
          emails = []
          for email in emaillist.replace(',', ' ').split(' '):
            if '' != email.strip():
              emails.append(email.strip())

          if options.mail:
            if options.debug:
              print "  Overriding emails ('%s') to '%s'" % (emaillist, options.mail)
            emails = []
            emails.append(options.mail)
            
          if not emails:
            # No emails, so no where to send it.
            if options.debug:
              print "  No email addresses registered. Skipping."
            continue
          
          xml = etree.Element('clientsplugin')
          
          # Place basic client info here
          client = etree.SubElement(xml, 'client')
          etree.SubElement(client, 'name').text = name
          etree.SubElement(client, 'lastupdate').text = myformat_date(lastupdate)

          have_data = False
          if 'summary' == field:
            # Load in a summary of the client's tickets
            sql = ("""\
              SELECT t.id, t.summary, t.description, t.status, t.milestone, m.due
              FROM ticket_custom tcust
              INNER JOIN ticket t ON tcust.ticket=t.id
              LEFT JOIN milestone m ON t.milestone=m.name
              WHERE tcust.name = 'client'
                AND tcust.value = %s
                AND t.status != 'closed'
              """)
            cur2 = db.cursor()
            cur2.execute(sql, (name,))
            xsummary = etree.SubElement(xml, 'summary')
            for tid, summary, description, status, milestone, due in cur2:
              have_data = True
              if options.debug:
                print "  Summarising ticket #%s" % tid
              ticket = etree.SubElement(xsummary, 'ticket')
              etree.SubElement(ticket, 'id').text = str(tid)
              etree.SubElement(ticket, 'summary').text = summary
              ticket.append(etree.XML('<description>%s</description>' % wiki_to_html(extract_client_text(description), self.env, self.req)))
              etree.SubElement(ticket, 'status').text = status
              etree.SubElement(ticket, 'milestone').text = milestone
              etree.SubElement(ticket, 'due').text = myformat_date(due)

          elif 'changes' == field:
            # Load in any changes that have happend
            sql = ("""\
              SELECT t.id, t.summary, t.description, t.status, t.resolution, t.milestone, m.due, tchng.field, tchng.oldvalue, tchng.newvalue
              FROM ticket_custom tcust
              INNER JOIN ticket t ON tcust.ticket=t.id
              INNER JOIN ticket_change tchng ON t.id=tchng.ticket
              LEFT JOIN milestone m ON t.milestone=m.name
              WHERE tcust.name = 'client'
                AND tcust.value = %s
                AND tchng.field IN ('comment', 'status', 'resolution', 'milestone')
                AND tchng.time >= %s
                AND tchng.time < %s
              ORDER BY t.time
              """)
            cur2 = db.cursor()
            cur2.execute(sql, (name, lastupdate, now))
            changes = etree.SubElement(xml, 'changes')
            lasttid = 0
            for tid, summary, description, status, resolution, milestone, due, cgfield, oldvalue, newvalue in cur2:
              text = ''
              if 'status' == cgfield:
                text = 'Status changed from "%s" to "%s"' % (oldvalue, newvalue)
              elif 'milestone' == cgfield:
                text = 'Milestone changed from "%s" to "%s" - please check for revised delivery date.' % (oldvalue, newvalue)
              elif 'resolution' == cgfield:
                if oldvalue and not newvalue:
                  text = 'Resolution removed'
                elif not oldvalue and newvalue:
                  text = 'Resolution set to "%s"' % (newvalue)
                else:
                  text = 'Resolution changed from "%s" to "%s"' % (oldvalue, newvalue)
              elif 'comment' == cgfield:
                # Todo - extract...
                text = extract_client_text(newvalue).strip()
                if '' == text:
                  # No comments for the client here so ignore it.
                  continue
                text = "''Comment for your information:''[[BR]][[BR]]" + text
              else:
                # Client should not know any more than this
                continue
              
              if options.debug:
                print "  Change notification (%s) for ticket #%s" % (cgfield, tid)
              have_data = True
              if lasttid != tid:
                ticket = etree.SubElement(changes, 'ticket')
                etree.SubElement(ticket, 'id').text = str(tid)
                etree.SubElement(ticket, 'summary').text = summary
                ticket.append(etree.XML('<description>%s</description>' % wiki_to_html(extract_client_text(description), self.env, self.req)))
                etree.SubElement(ticket, 'status').text = status
                etree.SubElement(ticket, 'resolution').text = resolution
                etree.SubElement(ticket, 'milestone').text = milestone
                etree.SubElement(ticket, 'due').text = myformat_date(due)
                changelog = etree.SubElement(ticket, 'changelog')

              detail = etree.XML('<detail>%s</detail>' % wiki_to_html(text, self.env, self.req))
              detail.set('field', cgfield)
              if oldvalue:
                detail.set('oldvalue', oldvalue)
              if newvalue:
                detail.set('newvalue', newvalue)
              changelog.append(detail)
              lasttid = tid
            
          if options.debug:
            file = open('/tmp/send-client-email.xml', 'w')
            file.write(etree.tostring(xml, pretty_print=True))
            file.close()
            print " Wrote XML to /tmp/send-client-email.xml"

          if not have_data:
            continue

          subject = 'Ticket Summary for %s' % name
          if 'changes' == field:
            subject = 'Ticket Change Summary for %s' % name
          if options.debug:
            print "  Sending email '%s'" % subject
          mailer.Send(subject, emails, xml, transform)

          if not options.debug:
            # Update the date field
            sql = ("UPDATE client SET %s_lastupdate" % field) + \
                   "=%s WHERE name=%s"
            cursor2 = db.cursor()
            cursor2.execute(sql, (now, name))
          
        db.commit()
        db.close()

if __name__ == "__main__":
    if not options.envpath:
        print "For usage: %s --help" % (sys.argv[0])
    else:
        SendClientEmails()
