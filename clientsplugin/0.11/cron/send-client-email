#!/usr/bin/env python

# send-client-email
# ----------------------------------------------------------------------------
# Copyright (c) 2007 Colin Guthrie
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
#   The above copyright notice and this permission notice shall be included in
#   all copies or substantial portions of the Software. 
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
# ----------------------------------------------------------------------------

# This email integration script is meant to interface to the Trac
# (http://www.edgewall.com/products/trac/) issue tracking/wiki/etc
# system


import re
import os
import sys
import locale
import time
import libxml2
import libxslt
from datetime import datetime
from optparse import OptionParser
from StringIO import StringIO

from trac import __version__
from trac.core import *
from trac.env import open_environment
from trac.util.datefmt import format_date, to_datetime


parser = OptionParser()
depr = '(not used anymore)'
parser.add_option('-e', '--env', dest='envpath',
                  help='Required. Path to the Trac environment.')
parser.add_option('-p', '--period', dest='period',
                  help='Period string as specified in the configuration of notifications. Defaults to "daily"')
parser.add_option('-t', '--type', dest='mailtype',
                  choices=['summary','changes'],
                  help='The type of email. Can be either "summary" (default) or "changes".')
parser.add_option('-x', '--xslt', dest='xslt',
                  help='The XSLT used to convert the change information to an email (optional, will use "MAILTYPE.xslt" from the current folder).')
parser.set_defaults(period='daily', mailtype='summary')
(options, args) = parser.parse_args(sys.argv[1:])


class SendClientMailer(object):
  def __init__(self, env):
    self.env = env
    self.config = env.config
  
  def Send(self, subject, addresses, info, formatter):
    if not self.config.getbool('notification', 'smtp_enabled'):
      return
    smtp_server = self.config['notification'].get('smtp_server')
    smtp_port = self.config['notification'].getint('smtp_port')
    from_email = self.config['notification'].get('smtp_from')
    from_name = self.config['notification'].get('smtp_from_name')
    replyto_email = self.config['notification'].get('smtp_replyto')
    from_email = from_email or replyto_email
    if not from_email:
      return
    
    # Authentication info (optional)
    user_name = self.config['notification'].get('smtp_user')
    password = self.config['notification'].get('smtp_password')
    
    # Thanks to the author of this recipe:
    # http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/473810
    
    from email.MIMEMultipart import MIMEMultipart
    from email.MIMEText import MIMEText
    from email.MIMEImage import MIMEImage
    
    projname = self.config.get('project', 'name')
    
    # Create the root message and fill in the from, to, and subject headers
    msg_root = MIMEMultipart('related')
    msg_root['To'] = str(', ').join(addresses)
    
    msg_root['X-Mailer'] = 'ClientsPlugin for Trac'
    msg_root['X-Trac-Version'] =  __version__
    msg_root['X-Trac-Project'] =  projname
    msg_root['Precedence'] = 'bulk'
    msg_root['Auto-Submitted'] = 'auto-generated'
    msg_root['Subject'] = subject
    msg_root['From'] = '%s <%s>' % (from_name or projname, from_email)
    msg_root['Reply-To'] = replyto_email
    msg_root.preamble = 'This is a multi-part message in MIME format.'
    
    # Encapsulate the plain and HTML versions of the message body in an
    # 'alternative' part, so message agents can decide which they want to display.
    msg_alternative = MIMEMultipart('alternative')
    msg_root.attach(msg_alternative)
    
    
    view = 'plain'
    result = formatter.applyStylesheet(info, {'view': '"%s"' % view })
    msg_text = MIMEText(formatter.saveResultToString(result), view, 'utf-8')
    msg_alternative.attach(msg_text)
    result.freeDoc()
    
    view = 'html'
    result = formatter.applyStylesheet(info, {'view': '"%s"' % view })
    msg_text = MIMEText(formatter.saveResultToString(result), view, 'utf-8')
    msg_alternative.attach(msg_text)
    result.freeDoc()
    
    # Handle image embedding...
    view = 'images'
    result = formatter.applyStylesheet(info, {'view': '"%s"' % view })
    if result and result.children and result.children.children:
      for img in result.children.children:
        if 'img' != img.name:
          continue
        if not img.hasProp('id') or not img.hasProp('src'):
          continue
        
        fp = open(img.prop('src'), 'rb')
        if not fp:
          continue
        msg_img = MIMEImage(fp.read())
        fp.close()
        msg_img.add_header('Content-ID', '<%s>' % img.prop('id'))
        msg_root.attach(msg_img)
    result.freeDoc()
    
    # Send the email (this example assumes SMTP authentication is required)
    import smtplib
    smtp = smtplib.SMTP() #smtp_server, smtp_port)
    if False and user_name:
        smtp.login(user_name, password)
    smtp.connect()
    smtp.sendmail(from_email, addresses, msg_root.as_string())
    smtp.quit()

class SendClientEmails:

    def __init__(self):
        global xslthackview
        
        locale.setlocale(locale.LC_ALL, '')
        self.env = open_environment(options.envpath)
        from clients.processor import extract_client_text

        # Sync the repo so that any commits that happen to have been made
        # that include client comments are included.
        repos = self.env.get_repository()
        repos.sync()
        
        field = 'summary'
        if 'changes' == options.mailtype:
          field = 'changes'
        
        stylesheet = '%s.xslt' % options.mailtype
        if options.xslt:
          stylesheet = options.xslt
        
        try:
          styledoc = libxml2.parseFile(stylesheet)
          style = libxslt.parseStylesheetDoc(styledoc)
        except:
          print "Error: Cannot load/parse stylesheet '%s'" % stylesheet
          exit(1)
          
        
        sql = ("SELECT name, %s_list, %s_lastupdate "
               "FROM client "
               "WHERE %s_period=" % (field, field, field)) + "%s"
        
        now = int(time.time())
        mailer = SendClientMailer(self.env)
        db = self.env.get_db_cnx()
        cursor = db.cursor()
        cursor.execute(sql, (options.period,))
        for name, emaillist, lastupdate in cursor:
          # Don't clobber clients with historical updates
          if not lastupdate:
              lastupdate = now
          
          emails = []
          for email in emaillist.replace(',', ' ').split(' '):
            if '' != email.strip():
              emails.append(email.strip())
          
          if not emails:
            # No emails, so no where to send it.
            continue
          
          xml = StringIO()
          xml.write('<clientsplugin>')
          
          # Place basic client info here
          xml.write('<client>')
          xml.write('<name>%s</name>' % name)
          xml.write('<lastupdate>%s</lastupdate>' % format_date(lastupdate))
          xml.write('</client>')
          
          have_data = False
          if 'summary' == field:
            # Load in a summary of the client's tickets
            ## NB the disabled second part of the query would have
            ##    returned tickets closed since last summary, but really
            ##    that's what the change notificiation is for...
            sql = ("""\
              SELECT t.id, t.summary, t.description, t.status, m.due
              FROM ticket t
              LEFT JOIN milestone m ON t.milestone=m.name 
              WHERE t.id IN
                (
                  SELECT ticket 
                  FROM ticket_custom tcust 
                  WHERE tcust.name = 'client'
                    AND tcust.value = %s
                )
                AND
                (
                  t.status IN ('new','assigned','reopened')
                  OR
                  (
                    0
                    AND t.status='closed'
                    AND t.id IN
                      (
                        SELECT tchng.ticket
                        FROM ticket_change tchng
                        WHERE tchng.ticket=t.id
                          AND tchng.field='status'
                          AND tchng.oldvalue != 'closed'
                          AND tchng.time >= %s
                          AND tchng.time < %s
                      )
                  )
                )
              """)
            cur2 = db.cursor()
            cur2.execute(sql, (name, lastupdate, now))
            xml.write('<summary>')
            for tid, summary, description, status, due in cur2:
              have_data = True
              xml.write('<ticket>')
              xml.write('<id>%s</id>' % tid)
              xml.write('<summary>%s</summary>' % summary)
              xml.write('<description>%s</description>' % extract_client_text(description))
              xml.write('<status>%s</status>' % status)
              xml.write('<due>%s</due>' % format_date(due))
              xml.write('</ticket>')
            
            xml.write('</summary>')
          
          elif 'changes' == field:
            # Load in any changes that have happend
            sql = ("""\
              SELECT t.id, t.summary, t.description, m.due, tchng.field, tchng.oldvalue, tchng.newvalue
              FROM ticket_custom tcust
              LEFT JOIN ticket t ON tcust.ticket=t.id
              LEFT JOIN ticket_change tchng ON t.id=tchng.ticket
              LEFT JOIN milestone m ON t.milestone=m.name
              WHERE tcust.name = 'client'
                AND tcust.value = %s
                AND tchng.field IN ('comment', 'status', 'milestone')
                AND tchng.time >= %s
                AND tchng.time < %s
              ORDER BY t.time
              """)
            cur2 = db.cursor()
            cur2.execute(sql, (name, lastupdate, now))
            xml.write('<changes>')
            lasttid = 0
            for tid, summary, description, due, cgfield, oldvalue, newvalue in cur2:
              text = ''
              if 'status' == cgfield:
                text = 'Status changed from &quot;%s&quot; to &quot;%s&quot;' % (oldvalue, newvalue)
              elif 'milestone' == cgfield:
                text = 'Milestone updated - please check for revised delivery date.'
              elif 'comment' == cgfield:
                # Todo - extract...
                text = extract_client_text(newvalue).strip()
                if '' == text:
                  # No comments for the client here so ignore it.
                  continue
                text = '<em>Comments for your attention:</em><br /><br />' + text
              else:
                # Client should not know any more than this
                continue
              
              have_data = True
              if lasttid and lasttid != tid:
                xml.write('</changelog>')
                xml.write('</ticket>')
              
              if lasttid != tid:
                xml.write('<ticket>')
                xml.write('<id>%s</id>' % tid)
                xml.write('<summary>%s</summary>' % summary)
                xml.write('<description>%s</description>' % extract_client_text(description))
                xml.write('<due>%s</due>' % format_date(due))
                xml.write('<changelog>')
              
              xml.write('<detail>%s</detail>' % text)
              lasttid = tid
            
            if lasttid:
              xml.write('</changelog>')
              xml.write('</ticket>')
            xml.write('</changes>')
          
          if not have_data:
            continue
          xml.write('</clientsplugin>')
          
          doc = libxml2.parseDoc(xml.getvalue())
          mailer.Send('Ticket Summary for %s' % name,
                      emails, doc, style)
          doc.freeDoc()
          # Update the date field
          sql = ("UPDATE client SET %s_lastupdate" % field) + \
                 "=%s WHERE name=%s"
          cursor.execute(sql, (now, name))
        style.freeStylesheet()
        db.commit()
        db.close()

if __name__ == "__main__":
    if not options.envpath:
        print "For usage: %s --help" % (sys.argv[0])
    else:
        SendClientEmails()
