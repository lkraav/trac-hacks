#!/usr/bin/env python

# send-client-email
# ----------------------------------------------------------------------------
# Copyright (c) 2007 Colin Guthrie
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
#   The above copyright notice and this permission notice shall be included in
#   all copies or substantial portions of the Software. 
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
# ----------------------------------------------------------------------------

# This email integration script is meant to interface to the Trac
# (http://www.edgewall.com/products/trac/) issue tracking/wiki/etc
# system
#
# It should be called from the command line or Subversion hook script,
# such as via:
#
# /usr/bin/python /path/to/send-client-emails \
#  -e "<env>" -p <period> -t ["summary"|"changes"]
#

import re
import os
import sys
import locale
import time
import libxml2
import libxslt
from datetime import datetime
from optparse import OptionParser
from StringIO import StringIO

from trac import __version__
from trac.core import *
from trac.env import open_environment
from trac.util.datefmt import format_date, to_datetime


parser = OptionParser()
depr = '(not used anymore)'
parser.add_option('-e', '--env', dest='envpath',
                  help='Required. Path to the Trac environment.')
parser.add_option('-p', '--period', dest='period',
                  help='Period string as specified in the configuration of notifications. Defaults to "daily"')
parser.add_option('-t', '--type', dest='mailtype',
                  choices=['summary','changes'],
                  help='The type of email. Can be either "summary" (default) or "changes".')
parser.add_option('-x', '--xslt', dest='xslt',
                  help='The XSLT used to convert the change information to an email (optional, will use "MAILTYPE.xslt" from the current folder).')
parser.set_defaults(period='daily', mailtype='summary')
(options, args) = parser.parse_args(sys.argv[1:])


## Hideous hack to work around libxslt-python 1.1.22 bug
## http://bugzilla.gnome.org/show_bug.cgi?id=489854
xslthackview = 'plain'
def fxslthackview(ctx):
    global xslthackview

    #
    # Small check to verify the context is correcly accessed
    #
    try:
        pctxt = libxslt.xpathParserContext(_obj=ctx)
        ctxt = pctxt.context()
        tctxt = ctxt.transformContext()
        nodeName = tctxt.insertNode().name
    except:
        pass

    return xslthackview

libxslt.registerExtModuleFunction('hack', 'http://hack.com/hack', fxslthackview)
## End Hack

class SendClientMailer(object):
  def __init__(self, env):
    self.env = env
    self.config = env.config
  
  def Send(self, subject, addresses, info, formatter):
    global xslthackview
    if not self.config.getbool('notification', 'smtp_enabled'):
      return
    smtp_server = self.config['notification'].get('smtp_server')
    smtp_port = self.config['notification'].getint('smtp_port')
    from_email = self.config['notification'].get('smtp_from')
    from_name = self.config['notification'].get('smtp_from_name')
    replyto_email = self.config['notification'].get('smtp_replyto')
    from_email = from_email or replyto_email
    if not from_email:
      return
    
    # Authentication info (optional)
    user_name = self.config['notification'].get('smtp_user')
    password = self.config['notification'].get('smtp_password')
    
    # Thanks to the author of this recipe:
    # http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/473810
    
    from email.MIMEMultipart import MIMEMultipart
    from email.MIMEText import MIMEText
    from email.MIMEImage import MIMEImage
    
    projname = self.config.get('project', 'name')
    
    # Create the root message and fill in the from, to, and subject headers
    msg_root = MIMEMultipart('related')
    msg_root['To'] = str(', ').join(addresses)
    
    msg_root['X-Mailer'] = 'ClientsPlugin for Trac'
    msg_root['X-Trac-Version'] =  __version__
    msg_root['X-Trac-Project'] =  projname
    msg_root['Precedence'] = 'bulk'
    msg_root['Auto-Submitted'] = 'auto-generated'
    msg_root['Subject'] = subject
    msg_root['From'] = '%s <%s>' % (from_name or projname, from_email)
    msg_root['Reply-To'] = replyto_email
    msg_root.preamble = 'This is a multi-part message in MIME format.'
    
    # Encapsulate the plain and HTML versions of the message body in an
    # 'alternative' part, so message agents can decide which they want to display.
    msg_alternative = MIMEMultipart('alternative')
    msg_root.attach(msg_alternative)
    
    
    # This should use XSLT params... but it's b0rken
    view = 'plain'
    xslthackview = view
    result = formatter.applyStylesheet(info, None)
    msg_text = MIMEText(formatter.saveResultToString(result), view, 'utf-8')
    msg_alternative.attach(msg_text)
    result.freeDoc()
    
    view = 'html'
    xslthackview = view
    result = formatter.applyStylesheet(info, None)
    msg_text = MIMEText(formatter.saveResultToString(result), view, 'utf-8')
    msg_alternative.attach(msg_text)
    result.freeDoc()
    
    # Handle image embedding...
    view = 'images'
    xslthackview = view
    result = formatter.applyStylesheet(info, None)
    if result and result.children and result.children.children:
      for img in result.children.children:
        if 'img' != img.name:
          continue
        if not img.hasProp('id') or not img.hasProp('src'):
          continue
        
        fp = open(img.prop('src'), 'rb')
        if not fp:
          continue
        msg_img = MIMEImage(fp.read())
        fp.close()
        msg_img.add_header('Content-ID', '<%s>' % img.prop('id'))
        msg_root.attach(msg_img)
    result.freeDoc()
    
    # Send the email (this example assumes SMTP authentication is required)
    import smtplib
    smtp = smtplib.SMTP() #smtp_server, smtp_port)
    if False and user_name:
        smtp.login(user_name, password)
    smtp.connect()
    smtp.sendmail(from_email, addresses, msg_root.as_string())
    smtp.quit()

class SendClientEmails:

    def __init__(self):
        global xslthackview
        
        locale.setlocale(locale.LC_ALL, '')
        self.env = open_environment(options.envpath)
        from clients.processor import extract_client_text

        # Sync the repo so that any commits that happen to have been made
        # that include client comments are included.
        repos = self.env.get_repository()
        repos.sync()
        
        field = 'summary'
        if 'changes' == options.mailtype:
          field = 'changes'
        
        stylesheet = '%s.xslt' % options.mailtype
        if options.xslt:
          stylesheet = options.xslt
        
        try:
          styledoc = libxml2.parseFile(stylesheet)
          style = libxslt.parseStylesheetDoc(styledoc)
        except:
          print "Error: Cannot load/parse stylesheet '%s'" % stylesheet
          exit(1)
          
        
        sql = ("SELECT name, %s_list, %s_lastupdate "
               "FROM client "
               "WHERE %s_period=" % (field, field, field)) + "%s"
        
        now = int(time.time())
        mailer = SendClientMailer(self.env)
        db = self.env.get_db_cnx()
        cursor = db.cursor()
        cursor.execute(sql, (options.period,))
        for name, emaillist, lastupdate in cursor:
          # Don't clobber clients with historical updates
          if not lastupdate:
              lastupdate = now
          
          emails = []
          for email in emaillist.replace(',', ' ').split(' '):
            if '' != email.strip():
              emails.append(email.strip())
          
          if not emails:
            # No emails, so no where to send it.
            continue
          
          xml = StringIO()
          xml.write('<clientsplugin>')
          
          # Place basic client info here
          xml.write('<client>')
          xml.write('<name>%s</name>' % name)
          xml.write('<lastupdate>%s</lastupdate>' % format_date(lastupdate))
          xml.write('</client>')
          
          # Load in a summary of the client's tickets
          ## NB the disabled second part of the query would have
          ##    returned tickets closed since last summary, but really
          ##    that's what the change notificiation is for...
          sql = ("""\
            SELECT t.id, t.summary, t.description, t.status, m.due
            FROM ticket t
            LEFT JOIN milestone m ON t.milestone=m.name 
            WHERE t.id IN
              (
                SELECT ticket 
                FROM ticket_custom tcust 
                WHERE tcust.name = 'client'
                  AND tcust.value = %s
              )
              AND
              (
                t.status IN ('new','assigned','reopened')
                OR
                (
                  0
                  AND t.status='closed'
                  AND t.id IN
                    (
                      SELECT tchng.ticket
                      FROM ticket_change tchng
                      WHERE tchng.ticket=t.id
                        AND tchng.field='status'
                        AND tchng.oldvalue != 'closed'
                        AND tchng.time >= %s
                        AND tchng.time < %s
                    )
                )
              )
            """)
          cur2 = db.cursor()
          cur2.execute(sql, (name, lastupdate, now))
          xml.write('<summary>')
          for tid, summary, description, status, due in cur2:
            xml.write('<ticket>')
            xml.write('<id>%s</id>' % tid)
            xml.write('<summary>%s</summary>' % summary)
            xml.write('<description>%s</description>' % extract_client_text(description))
            xml.write('<status>%s</status>' % status)
            xml.write('<due>%s</due>' % format_date(due))
            xml.write('</ticket>')
          
          xml.write('</summary>')

          # Load in any changes that have happend
          sql = ("""\
            SELECT t.id, t.summary, m.due, tchng.field, tchng.oldvalue, tchng.newvalue
            FROM ticket_custom tcust
            LEFT JOIN ticket t ON tcust.ticket=t.id
            LEFT JOIN ticket_change tchng ON t.id=tchng.ticket
            LEFT JOIN milestone m ON t.milestone=m.name
            WHERE tcust.name = 'client'
              AND tcust.value = %s
              AND tchng.time >= %s
              AND tchng.time < %s
            ORDER BY t.time
            """)
          cur2 = db.cursor()
          cur2.execute(sql, (name, lastupdate, now))
          xml.write('<changes>')
          for tid, summary, due, field, oldvalue, newvalue in cur2:
            text = ''
            if 'status' == field:
              text = 'Status changed from "%s" to "%s"' % (oldvalue, newvalue)
            elif 'comment' == field:
              # Todo - extract...
              text = extract_client_text(newvalue)
              if '' == text.strip():
                # No comments for the client here so ignore it.
                continue
            else:
              # Client should not know any more than this
              continue
            
            xml.write('<ticket>')
            xml.write('<id>%s</id>' % tid)
            xml.write('<summary>%s</summary>' % summary)
            xml.write('<due>%s</due>' % format_date(due))
            xml.write('<%s>%s</%s>' % (field, text, field))
            xml.write('</ticket>')
          xml.write('</changes>')
          xml.write('</clientsplugin>')
          
          doc = libxml2.parseDoc(xml.getvalue())
          mailer.Send('Ticket Summary for %s' % name,
                      emails, doc, style)
          doc.freeDoc()

        style.freeStylesheet()

if __name__ == "__main__":
    if not options.envpath:
        print "For usage: %s --help" % (sys.argv[0])
    else:
        SendClientEmails()
