diff -uNr usr/share/python-support/trac/trac/About.py /usr/share/python-support/trac/trac/About.py
--- usr/share/python-support/trac/trac/About.py	2006-08-08 11:33:10.000000000 +0200
+++ /usr/share/python-support/trac/trac/About.py	2007-05-03 20:02:21.494579257 +0200
@@ -38,7 +38,7 @@
 
     def get_navigation_items(self, req):
         yield ('metanav', 'about',
-               html.a('About Trac', href=req.href.about()))
+               html.a('Over Trac', href=req.href.about()))
 
     # IPermissionRequestor methods
 
@@ -56,7 +56,7 @@
 
     def process_request(self, req):
         page = req.args.get('page', 'default')
-        req.hdf['title'] = 'About Trac'
+        req.hdf['title'] = 'Over Trac'
         if req.perm.has_permission('CONFIG_VIEW'):
             req.hdf['about.config_href'] = req.href.about('config')
             req.hdf['about.plugins_href'] = req.href.about('plugins')
diff -uNr usr/share/python-support/trac/trac/attachment.py /usr/share/python-support/trac/trac/attachment.py
--- usr/share/python-support/trac/trac/attachment.py	2006-12-01 02:16:18.000000000 +0100
+++ /usr/share/python-support/trac/trac/attachment.py	2007-05-03 20:02:21.494579257 +0200
@@ -100,8 +100,8 @@
         cursor.close()
         if not row:
             self.filename = filename
-            raise TracError('Attachment %s does not exist.' % (self.title),
-                            'Invalid Attachment')
+            raise TracError('Bijlage %s bestaat niet.' % (self.title),
+                            'Ongeldige bijlage')
         self.filename = row[0]
         self.description = row[1]
         self.size = row[2] and int(row[2]) or 0
@@ -130,7 +130,7 @@
     title = property(_get_title)
 
     def delete(self, db=None):
-        assert self.filename, 'Cannot delete non-existent attachment'
+        assert self.filename, 'Kan niet bestaande bijlage niet verwijderen'
         if not db:
             db = self.env.get_db_cnx()
             handle_ta = True
@@ -149,7 +149,7 @@
                                    self.path, exc_info=True)
                 if handle_ta:
                     db.rollback()
-                raise TracError, 'Could not delete attachment'
+                raise TracError, 'Kan bijlage niet verwijderen'
 
         self.env.log.info('Attachment removed: %s' % self.title)
         if handle_ta:
@@ -250,7 +250,7 @@
         try:
             fd = open(self.path, 'rb')
         except IOError:
-            raise TracError('Attachment %s not found' % self.filename)
+            raise TracError('Bijlage %s niet gevonden' % self.filename)
         return fd
 
 
@@ -336,9 +336,9 @@
         parent_type = req.args.get('type')
         path = req.args.get('path')
         if not parent_type or not path:
-            raise HTTPBadRequest('Bad request')
+            raise HTTPBadRequest('Ongeldig verzoek')
         if not parent_type in ['ticket', 'wiki']:
-            raise HTTPBadRequest('Unknown attachment type')
+            raise HTTPBadRequest('Bestandstype bijlage onbekend')
 
         action = req.args.get('action', 'view')
         if action == 'new':
@@ -351,7 +351,7 @@
                 self._render_list(req, parent_type, last_segment)
                 return 'attachment.cs', None
             if not last_segment:
-                raise HTTPBadRequest('Bad request')
+                raise HTTPBadRequest('Ongeldig verzoek')
             attachment = Attachment(self.env, parent_type, parent_id,
                                     last_segment)
         parent_link, parent_text = self._parent_to_hdf(
@@ -376,7 +376,7 @@
         # Populate attachment.parent:
         parent_link = req.href(parent_type, parent_id)
         if parent_type == 'ticket':
-            parent_text = 'Ticket #' + parent_id
+            parent_text = 'Melding #' + parent_id
         else: # 'wiki'
             parent_text = parent_id
         req.hdf['attachment.parent'] = {
@@ -427,7 +427,7 @@
                 href = req.abs_href
             else:
                 descr = wiki_to_oneliner(descr, self.env, db, shorten=True)
-                title += Markup(' by %s', author)
+                title += Markup(' door %s', author)
                 href = req.href
             yield('attachment', href.attachment(type, id, filename), title,
                   time, author, descr)
@@ -443,19 +443,19 @@
 
         upload = req.args['attachment']
         if not hasattr(upload, 'filename') or not upload.filename:
-            raise TracError('No file uploaded')
+            raise TracError('Geen bestand ontvangen')
         if hasattr(upload.file, 'fileno'):
             size = os.fstat(upload.file.fileno())[6]
         else:
             size = upload.file.len
         if size == 0:
-            raise TracError("Can't upload empty file")
+            raise TracError("Kan leeg bestand niet versturen")
 
         # Maximum attachment size (in bytes)
         max_size = self.max_size
         if max_size >= 0 and size > max_size:
-            raise TracError('Maximum attachment size: %d bytes' % max_size,
-                            'Upload failed')
+            raise TracError('Maximale bestandsgrootte van bijlagen: %d bytes' % max_size,
+                            'Upload mislukt')
 
         # We try to normalize the filename to unicode NFC if we can.
         # Files uploaded from OS X might be in NFD.
@@ -464,7 +464,7 @@
         filename = filename.replace('\\', '/').replace(':', '/')
         filename = os.path.basename(filename)
         if not filename:
-            raise TracError('No file uploaded')
+            raise TracError('Geen bestand verstuurd')
 
         attachment.description = req.args.get('description', '')
         attachment.author = get_reporter_id(req, 'author')
@@ -474,10 +474,10 @@
         for manipulator in self.manipulators:
             for field, message in manipulator.validate_attachment(req, attachment):
                 if field:
-                    raise InvalidAttachment('Attachment field %s is invalid: %s'
+                    raise InvalidAttachment('Veld van bijlage %s is ongeldig: %s'
                                             % (field, message))
                 else:
-                    raise InvalidAttachment('Invalid attachment: %s' % message)
+                    raise InvalidAttachment('Ongeldige bijlage: %s' % message)
 
         if req.args.get('replace'):
             try:
@@ -512,7 +512,7 @@
         perm_map = {'ticket': 'TICKET_ADMIN', 'wiki': 'WIKI_DELETE'}
         req.perm.assert_permission(perm_map[attachment.parent_type])
 
-        req.hdf['title'] = '%s (delete)' % attachment.title
+        req.hdf['title'] = '%s (verwijder)' % attachment.title
         req.hdf['attachment'] = {'filename': attachment.filename,
                                  'mode': 'delete'}
 
@@ -572,12 +572,12 @@
             if self.render_unsafe_content and not binary and \
                mime_type and not mime_type.startswith('text/plain'):
                 plaintext_href = attachment.href(req, format='txt')
-                add_link(req, 'alternate', plaintext_href, 'Plain Text',
+                add_link(req, 'alternate', plaintext_href, 'Standaard tekst',
                          mime_type)
 
             # add ''Original Format'' alternate link (always)
             raw_href = attachment.href(req, format='raw')
-            add_link(req, 'alternate', raw_href, 'Original Format', mime_type)
+            add_link(req, 'alternate', raw_href, 'Origineel formaat', mime_type)
 
             self.log.debug("Rendering preview of file %s with mime-type %s"
                            % (attachment.filename, mime_type))
@@ -618,7 +618,7 @@
             if formatter.req:
                 href = attachment.href(formatter.req) + params
             return html.A(label, class_='attachment', href=href,
-                          title='Attachment %s' % attachment.title)
+                          title='Bijlage %s' % attachment.title)
         except TracError:
             return html.A(label, class_='missing attachment', rel='nofollow',
                           href=formatter.href())
diff -uNr usr/share/python-support/trac/trac/core.py /usr/share/python-support/trac/trac/core.py
--- usr/share/python-support/trac/trac/core.py	2006-09-13 14:31:25.000000000 +0200
+++ /usr/share/python-support/trac/trac/core.py	2007-05-03 20:02:21.494579257 +0200
@@ -174,11 +174,11 @@
         component = self.components.get(cls)
         if not component:
             if cls not in ComponentMeta._components:
-                raise TracError, 'Component "%s" not registered' % cls.__name__
+                raise TracError, 'Component "%s" niet geregistreerd' % cls.__name__
             try:
                 component = cls(self)
             except TypeError, e:
-                raise TracError, 'Unable to instantiate component %r (%s)' \
+                raise TracError, 'Kan component niet laden %r (%s)' \
                                  % (cls, e)
         return component
 
diff -uNr usr/share/python-support/trac/trac/env.py /usr/share/python-support/trac/trac/env.py
--- usr/share/python-support/trac/trac/env.py	2006-10-24 01:50:21.000000000 +0200
+++ /usr/share/python-support/trac/trac/env.py	2007-05-03 20:02:21.494579257 +0200
@@ -101,6 +101,39 @@
         
         Should be one of (`CRITICAL`, `ERROR`, `WARN`, `INFO`, `DEBUG`).""")
 
+    tr_fixed = Option('translation', 'fixed', u'opgelost', '')
+    tr_invalid = Option('translation', 'invalid', u'ongeldig', '')
+    tr_wontfix = Option('translation', 'wontfix', u'onoplosbaar', '')
+    tr_duplicate = Option('translation', 'duplicate', u'duplicaat', '')
+    tr_worksforme = Option('translation', 'worksforme', u'nietreproduceerbaar', '')
+    tr_new = Option('translation', 'new', u'nieuw', '')
+    tr_closed = Option('translation', 'closed', u'gesloten', '')
+    tr_assigned = Option('translation', 'assigned', u'toegekend', '')
+    tr_reopened = Option('translation', 'reopened', u'heropend', '')
+    tr_reassign = Option('translation', 'reassign', u'opnieuwtoegekend', '')
+    tr_blocker = Option('translation', 'blocker', u'blokkering', '')
+    tr_critical = Option('translation', 'critical', u'kritisch', '')
+    tr_major = Option('translation', 'major', u'majeur', '')
+    tr_minor = Option('translation', 'minor', u'mineur', '')
+    tr_trivial = Option('translation', 'trivial', u'triviaal', '')
+    tr_defect = Option('translation', 'defect', u'defect', '')
+    tr_enhancement = Option('translation', 'enhancement', u'verbetering', '')
+    tr_task = Option('translation', 'task', u'taak', '')
+    tr_component = Option('translation', 'component', u'onderdeel', '')
+    tr_keywords = Option('translation', 'keywords', u'sleutelwoorden', '')
+    tr_priority = Option('translation', 'priority', u'prioriteit', '')
+    tr_milestone = Option('translation', 'milestone', u'mijlpaal', '')
+    tr_summary = Option('translation', 'summary', u'samenvatting', '')
+    tr_resolution = Option('translation', 'resolution', u'oplossing', '')
+    tr_report = Option('translation', 'report', u'rapport', '')
+    tr_title = Option('translation', 'title', u'titel', '')
+    tr_owner = Option('translation', 'owner', u'eigenaar', '')
+    tr_reporter = Option('translation', 'reporter', u'rapporteur', '')
+    tr_created = Option('translation', 'created', u'aangemaakt', '')
+    tr_modified = Option('translation', 'modified', u'aangepast', '')
+    tr_change = Option('translation', 'change', u'wijziging', '')
+    tr_changeset = Option('translation', 'changeset', u'versie', '')
+
     def __init__(self, path, create=False, options=[]):
         """Initialize the Trac environment.
         
@@ -124,6 +157,7 @@
             self.create(options)
         else:
             self.verify()
+            self.init_translations()
 
         if create:
             for setup_participant in self.setup_participants:
@@ -247,6 +281,14 @@
                         value = None
                     self.config.set(section, name, value)
 
+    def init_translations(self):
+        self.translations = {}
+        for (k,v) in self.config.options('translation'):
+            self.translations[k] = v
+            ck = k.capitalize()
+            cv = v.capitalize()
+            self.translations[ck] = cv
+
     def get_templates_dir(self):
         """Return absolute path to the templates directory."""
         return os.path.join(self.path, 'templates')
diff -uNr usr/share/python-support/trac/trac/mimeview/api.py /usr/share/python-support/trac/trac/mimeview/api.py
--- usr/share/python-support/trac/trac/mimeview/api.py	2006-11-30 11:20:28.000000000 +0100
+++ /usr/share/python-support/trac/trac/mimeview/api.py	2007-05-03 20:08:14.997615611 +0200
@@ -330,7 +330,7 @@
 
     mime_map = ListOption('mimeviewer', 'mime_map',
         'text/x-dylan:dylan,text/x-idl:ice,text/x-ada:ads:adb',
-        doc="""List of additional MIME types and keyword mappings.
+        """List of additional MIME types and keyword mappings.
         Mappings are comma-separated, and for each MIME type,
         there's a colon (":") separated list of associated keywords
         or file extensions. (''since 0.10'').""")
@@ -349,7 +349,7 @@
             for k, n, e, im, om, q in converter.get_supported_conversions():
                 if im == mimetype and q > 0:
                     converters.append((k, n, e, im, om, q, converter))
-        converters = sorted(converters, key=lambda i: i[-2], reverse=True)
+        converters = sorted(converters, key=lambda i: i[-1], reverse=True)
         return converters
 
     def convert_content(self, req, mimetype, content, key, filename=None,
diff -uNr usr/share/python-support/trac/trac/mimeview/enscript.py /usr/share/python-support/trac/trac/mimeview/enscript.py
--- usr/share/python-support/trac/trac/mimeview/enscript.py	2006-10-12 09:22:12.000000000 +0200
+++ /usr/share/python-support/trac/trac/mimeview/enscript.py	2007-05-03 20:08:18.457741752 +0200
@@ -103,7 +103,7 @@
         """Path to the Enscript executable.""")
 
     enscript_modes = ListOption('mimeviewer', 'enscript_modes',
-        'text/x-dylan:dylan:4', doc=
+        'text/x-dylan:dylan:4',
         """List of additional MIME types known by Enscript.
         For each, a tuple `mimetype:mode:quality` has to be
         specified, where `mimetype` is the MIME type,
diff -uNr usr/share/python-support/trac/trac/mimeview/php.py /usr/share/python-support/trac/trac/mimeview/php.py
--- usr/share/python-support/trac/trac/mimeview/php.py	2006-11-24 14:43:33.000000000 +0100
+++ /usr/share/python-support/trac/trac/mimeview/php.py	2007-05-03 20:08:21.297845293 +0200
@@ -57,9 +57,9 @@
         return color_rules + [ r'(?P<font><font.*?>)', r'(?P<endfont></font>)' ]
     rules = classmethod(rules)
 
-
 class PHPRenderer(Component):
-    """Syntax highlighting using the PHP executable if available.
+    """
+    Syntax highlighting using the PHP executable if available.
     """
 
     implements(IHTMLPreviewRenderer)
@@ -75,25 +75,23 @@
         return 0
 
     def render(self, req, mimetype, content, filename=None, rev=None):
+        cmdline = self.config.get('mimeviewer', 'php_path')
         # -n to ignore php.ini so we're using default colors
-        cmdline = '%s -sn' % self.path
+        cmdline += ' -sn'
         self.env.log.debug("PHP command line: %s" % cmdline)
-
+        
         content = content_to_unicode(self.env, content, mimetype)
         content = content.encode('utf-8')
         np = NaivePopen(cmdline, content, capturestderr=1)
         if (os.name != 'nt' and np.errorlevel) or np.err:
-            msg = 'Running (%s) failed: %s, %s.' % (cmdline,
-                                                    np.errorlevel,
+            err = 'Running (%s) failed: %s, %s.' % (cmdline, np.errorlevel,
                                                     np.err)
-            raise Exception(msg)
-
+            raise Exception, err
         odata = ''.join(np.out.splitlines()[1:-1])
-        if odata.startswith('X-Powered-By:') or \
-                odata.startswith('Content-type:'):
-            raise TracError('You appear to be using the PHP CGI '
-                            'binary. Trac requires the CLI version '
-                            'for syntax highlighting.')
+        if odata.startswith('X-Powered-By'):
+            raise TracError, 'You appear to be using the PHP CGI binary.  ' \
+                             'Trac requires the CLI version for syntax ' \
+                             'highlighting.'
 
         epilogues = ["</span>", "</font>"]
         for e in epilogues:
diff -uNr usr/share/python-support/trac/trac/mimeview/silvercity.py /usr/share/python-support/trac/trac/mimeview/silvercity.py
--- usr/share/python-support/trac/trac/mimeview/silvercity.py	2006-11-14 15:48:14.000000000 +0100
+++ /usr/share/python-support/trac/trac/mimeview/silvercity.py	2007-05-03 20:08:21.297845293 +0200
@@ -63,8 +63,8 @@
 
     implements(IHTMLPreviewRenderer)
 
-    silvercity_modes = ListOption('mimeviewer', 'silvercity_modes',
-        '', doc=
+    enscript_modes = ListOption('mimeviewer', 'silvercity_modes',
+        '',
         """List of additional MIME types known by SilverCity.
         For each, a tuple `mimetype:mode:quality` has to be
         specified, where `mimetype` is the MIME type,
diff -uNr usr/share/python-support/trac/trac/perm.py /usr/share/python-support/trac/trac/perm.py
--- usr/share/python-support/trac/trac/perm.py	2006-11-27 23:17:32.000000000 +0100
+++ /usr/share/python-support/trac/trac/perm.py	2007-07-07 23:17:06.433743146 +0200
@@ -21,6 +21,7 @@
 from trac.config import ExtensionOption
 from trac.core import *
 
+
 __all__ = ['IPermissionRequestor', 'IPermissionStore',
            'IPermissionGroupProvider', 'PermissionError', 'PermissionSystem']
 
@@ -32,7 +33,7 @@
         self.action = action
 
     def __str__ (self):
-        return '%s privileges are required to perform this operation' % self.action
+        return 'Voor het %s-recht dien je in te loggen' % self.action
 
 
 class IPermissionRequestor(Interface):
diff -uNr usr/share/python-support/trac/trac/scripts/admin.py /usr/share/python-support/trac/trac/scripts/admin.py
--- usr/share/python-support/trac/trac/scripts/admin.py	2006-11-24 10:44:33.000000000 +0100
+++ /usr/share/python-support/trac/trac/scripts/admin.py	2007-05-03 20:08:43.158642370 +0200
@@ -596,8 +596,6 @@
         if not os.access(os.path.join(templates_dir, 'header.cs'), os.F_OK):
             print templates_dir, "doesn't look like a Trac templates directory"
             return 2
-        if templates_dir == default_dir('templates'):
-            templates_dir = None # let the runtime default_dir() take over
 
         try:
             print 'Creating and Initializing Project'
@@ -678,8 +676,11 @@
         cursor = cnx.cursor()
         cursor.execute("DELETE FROM revision")
         cursor.execute("DELETE FROM node_change")
+        repos = self.__env.get_repository()
         cursor.execute("DELETE FROM system WHERE name='repository_dir'")
-        repos = self.__env.get_repository() # this will do the sync()
+        cursor.execute("INSERT INTO system (name,value) "
+                       "VALUES ('repository_dir',%s)", (repos.name,))
+        repos.sync()
         print 'Done.'
 
     ## Wiki
diff -uNr usr/share/python-support/trac/trac/Search.py /usr/share/python-support/trac/trac/Search.py
--- usr/share/python-support/trac/trac/Search.py	2006-09-24 23:14:41.000000000 +0200
+++ /usr/share/python-support/trac/trac/Search.py	2007-05-03 20:02:21.494579257 +0200
@@ -74,7 +74,7 @@
     parameters. The result is returned as a (string, params) tuple.
     """
     if len(columns) < 1 or len(terms) < 1:
-        raise TracError('Empty search attempt, this should really not happen.')
+        raise TracError('Leeg zoekresultaat; dit zou niet moeten gebeuren.')
 
     likes = ['%s %s' % (i, db.like()) for i in columns]
     c = ' OR '.join(likes)
@@ -132,7 +132,7 @@
         if not req.perm.has_permission('SEARCH_VIEW'):
             return
         yield ('mainnav', 'search',
-               html.A('Search', href=req.href.search(), accesskey=4))
+               html.A('Zoeken', href=req.href.search(), accesskey=4))
 
     # IPermissionRequestor methods
 
@@ -162,7 +162,7 @@
               'active': filter[0] in filters
             } for filter in available_filters]
                 
-        req.hdf['title'] = 'Search'
+        req.hdf['title'] = 'Zoeken'
 
         query = req.args.get('q')
         if query:
@@ -173,9 +173,9 @@
             terms = search_terms(query)
             # Refuse queries that obviously would result in a huge result set
             if len(terms) == 1 and len(terms[0]) < self.min_query_length:
-                raise TracError('Search query too short. '
-                                'Query must be at least %d characters long.' % \
-                                self.min_query_length, 'Search Error')
+                raise TracError('Zoekterm te kort. '
+                                'Een zoekopdracht moet uit minimaal %d karakters bestaan.' % \
+                                self.min_query_length, 'Zoekfout')
             results = []
             for source in self.search_sources:
                 results += list(source.get_search_results(req, terms, filters))
@@ -185,7 +185,7 @@
             n_pages = (n-1) / page_size + 1
             results = results[(page-1) * page_size: page * page_size]
 
-            req.hdf['title'] = 'Search Results'
+            req.hdf['title'] = 'Zoekresultaten'
             req.hdf['search.q'] = req.args.get('q')
             req.hdf['search.page'] = page
             req.hdf['search.n_hits'] = n
@@ -195,12 +195,12 @@
                 next_href = req.href.search(zip(filters, ['on'] * len(filters)),
                                             q=req.args.get('q'), page=page + 1,
                                             noquickjump=1)
-                add_link(req, 'next', next_href, 'Next Page')
+                add_link(req, 'next', next_href, 'Volgende pagina')
             if page > 1:
                 prev_href = req.href.search(zip(filters, ['on'] * len(filters)),
                                             q=req.args.get('q'), page=page - 1,
                                             noquickjump=1)
-                add_link(req, 'prev', prev_href, 'Previous Page')
+                add_link(req, 'prev', prev_href, 'Vorige pagina')
             req.hdf['search.page_href'] = req.href.search(
                 zip(filters, ['on'] * len(filters)), q=req.args.get('q'),
                 noquickjump=1)
@@ -222,7 +222,7 @@
         if kwd[0] == '/':
             quickjump_href = req.href.browser(kwd)
             name = kwd
-            description = 'Browse repository path ' + kwd
+            description = 'Blader door repository ' + kwd
         else:
             link = wiki_to_link(kwd, self.env, req)
             if isinstance(link, Element):
diff -uNr usr/share/python-support/trac/trac/Settings.py /usr/share/python-support/trac/trac/Settings.py
--- usr/share/python-support/trac/trac/Settings.py	2006-08-08 11:33:10.000000000 +0200
+++ /usr/share/python-support/trac/trac/Settings.py	2007-05-03 20:02:21.494579257 +0200
@@ -33,7 +33,7 @@
 
     def get_navigation_items(self, req):
         yield ('metanav', 'settings',
-               html.A('Settings', href=req.href.settings()))
+               html.A('Instellingen', href=req.href.settings()))
 
     # IRequestHandler methods
 
@@ -49,7 +49,7 @@
             elif action == 'load':
                 self._do_load(req)
 
-        req.hdf['title'] = 'Settings'
+        req.hdf['title'] = 'Instellingen'
         req.hdf['settings'] = req.session
         if req.authname == 'anonymous':
             req.hdf['settings.session_id'] = req.session.sid
diff -uNr usr/share/python-support/trac/trac/ticket/api.py /usr/share/python-support/trac/trac/ticket/api.py
--- usr/share/python-support/trac/trac/ticket/api.py	2006-10-11 16:30:24.000000000 +0200
+++ /usr/share/python-support/trac/trac/ticket/api.py	2007-05-03 20:08:06.957322514 +0200
@@ -65,7 +65,7 @@
 
     restrict_owner = BoolOption('ticket', 'restrict_owner', 'false',
         """Make the owner field of tickets use a drop-down menu. See
-        [TracTickets#Assign-toasDrop-DownList Assign-to as Drop-Down List]
+        [wiki:TracTickets#AssigntoasDropDownList AssignToAsDropDownList]
         (''since 0.9'').""")
 
     # Public API
@@ -168,9 +168,7 @@
             }
             if field['type'] == 'select' or field['type'] == 'radio':
                 field['options'] = config.getlist(name + '.options', sep='|')
-                if '' in field['options']:
-                    field['optional'] = True
-                    field['options'].remove('')
+                field['optional'] = '' in field['options']
             elif field['type'] == 'textarea':
                 field['width'] = config.getint(name + '.cols')
                 field['height'] = config.getint(name + '.rows')
diff -uNr usr/share/python-support/trac/trac/ticket/model.py /usr/share/python-support/trac/trac/ticket/model.py
--- usr/share/python-support/trac/trac/ticket/model.py	2006-11-28 09:16:10.000000000 +0100
+++ /usr/share/python-support/trac/trac/ticket/model.py	2007-05-03 20:08:06.957322514 +0200
@@ -36,7 +36,7 @@
         self.env = env
         self.fields = TicketSystem(self.env).get_ticket_fields()
         self.values = {}
-        if tkt_id is not None:
+        if tkt_id:
             self._fetch_ticket(tkt_id, db)
         else:
             self._init_defaults(db)
@@ -65,11 +65,14 @@
                 options = field.get('options')
                 if default and options and default not in options:
                     try:
-                        default = options[int(default)]
-                    except (ValueError, IndexError):
-                        self.env.log.warning('Invalid default value "%s" '
-                                             'for custom field "%s"'
-                                             % (default, field['name']))
+                        default_idx = int(default)
+                        if default_idx > len(options):
+                            raise ValueError
+                        default = options[default_idx]
+                    except ValueError:
+                        self.env.log.warning('Invalid default value for '
+                                             'custom field "%s"'
+                                             % field['name'])
             if default:
                 self.values.setdefault(field['name'], default)
 
@@ -83,8 +86,8 @@
                        % ','.join(std_fields), (tkt_id,))
         row = cursor.fetchone()
         if not row:
-            raise TracError('Ticket %d does not exist.' % tkt_id,
-                            'Invalid Ticket Number')
+            raise TracError('Melding %d bestaat niet.' % tkt_id,
+                            'Ongeldig meldingsnummer')
 
         self.id = tkt_id
         for i in range(len(std_fields)):
@@ -131,7 +134,7 @@
 
     def insert(self, when=0, db=None):
         """Add ticket to database"""
-        assert not self.exists, 'Cannot insert an existing ticket'
+        assert not self.exists, 'Kan een reeds bestaande melding niet opnieuw invoeren'
         db, handle_ta = self._get_db_for_write(db)
 
         # Add a timestamp
@@ -184,13 +187,12 @@
     def save_changes(self, author, comment, when=0, db=None, cnum=''):
         """
         Store ticket changes in the database. The ticket must already exist in
-        the database.  Returns False if there were no changes to save, True
-        otherwise.
+        the database.
         """
-        assert self.exists, 'Cannot update a new ticket'
+        assert self.exists, 'Kan melding niet bijwerken'
 
         if not self._old and not comment:
-            return False # Not modified
+            return # Not modified
 
         db, handle_ta = self._get_db_for_write(db)
         cursor = db.cursor()
@@ -260,7 +262,6 @@
 
         for listener in TicketSystem(self.env).change_listeners:
             listener.ticket_changed(self, comment, author, old_values)
-        return True
 
     def get_changelog(self, when=0, db=None):
         """Return the changelog as a list of tuples of the form
@@ -331,7 +332,7 @@
                            (self.type, name))
             row = cursor.fetchone()
             if not row:
-                raise TracError, '%s %s does not exist.' % (self.type, name)
+                raise TracError, '%s %s bestaat niet.' % (self.type, name)
             self.value = self._old_value = row[0]
             self.name = self._old_name = name
         else:
@@ -341,7 +342,7 @@
     exists = property(fget=lambda self: self._old_value is not None)
 
     def delete(self, db=None):
-        assert self.exists, 'Cannot deleting non-existent %s' % self.type
+        assert self.exists, 'Kan %s niet verwijderen (bestaat niet)' % self.type
         if not db:
             db = self.env.get_db_cnx()
             handle_ta = True
@@ -359,8 +360,8 @@
         self.name = self._old_name = None
 
     def insert(self, db=None):
-        assert not self.exists, 'Cannot insert existing %s' % self.type
-        assert self.name, 'Cannot create %s with no name' % self.type
+        assert not self.exists, 'Kan bestaande %s niet invoegen' % self.type
+        assert self.name, 'Kan %s niet maken (geen naam)' % self.type
         self.name = self.name.strip()
         if not db:
             db = self.env.get_db_cnx()
@@ -384,8 +385,8 @@
         self._old_value = self.value
 
     def update(self, db=None):
-        assert self.exists, 'Cannot update non-existent %s' % self.type
-        assert self.name, 'Cannot update %s with no name' % self.type
+        assert self.exists, 'Kan %s niet bijwerken (bestaat niet)' % self.type
+        assert self.name, 'Kan %s niet bijwerken (geen naam)' % self.type
         self.name = self.name.strip()
         if not db:
             db = self.env.get_db_cnx()
@@ -457,7 +458,7 @@
                            "WHERE name=%s", (name,))
             row = cursor.fetchone()
             if not row:
-                raise TracError, 'Component %s does not exist.' % name
+                raise TracError, 'Onderdeel %s bestaat niet.' % name
             self.name = self._old_name = name
             self.owner = row[0] or None
             self.description = row[1] or ''
@@ -469,7 +470,7 @@
     exists = property(fget=lambda self: self._old_name is not None)
 
     def delete(self, db=None):
-        assert self.exists, 'Cannot deleting non-existent component'
+        assert self.exists, 'Kan een niet bestaand onderdeel niet verwijderen'
         if not db:
             db = self.env.get_db_cnx()
             handle_ta = True
@@ -486,8 +487,8 @@
             db.commit()
 
     def insert(self, db=None):
-        assert not self.exists, 'Cannot insert existing component'
-        assert self.name, 'Cannot create component with no name'
+        assert not self.exists, 'Kan reeds bestaand onderdeel niet invoegen'
+        assert self.name, 'Kan onderdeel niet maken (geen naam)'
         self.name = self.name.strip()
         if not db:
             db = self.env.get_db_cnx()
diff -uNr usr/share/python-support/trac/trac/ticket/notification.py /usr/share/python-support/trac/trac/ticket/notification.py
--- usr/share/python-support/trac/trac/ticket/notification.py	2006-11-16 02:06:26.000000000 +0100
+++ /usr/share/python-support/trac/trac/ticket/notification.py	2007-05-03 20:08:06.957322514 +0200
@@ -63,8 +63,6 @@
         self.ticket['description'] = wrap(self.ticket.values.get('description', ''),
                                           self.COLS, initial_indent=' ',
                                           subsequent_indent=' ', linesep=CRLF)
-        self.reporter = ''
-        self.owner = ''
         self.hdf.set_unescaped('email.ticket_props', self.format_props())
         self.hdf.set_unescaped('email.ticket_body_hdr', self.format_hdr())
         self.hdf['ticket.new'] = self.newticket
@@ -186,14 +184,9 @@
                                                  self.COLS, linesep=CRLF))
 
     def format_subj(self):
-        prefix = self.config.get('notification', 'smtp_subject_prefix')
-        if prefix == '__default__': 
-            prefix = '[%s]' % self.config.get('project', 'name') 
-        if prefix: 
-            return '%s #%s: %s' % (prefix, self.ticket.id,
-                                  self.ticket['summary'])
-        else:
-            return '#%s: %s' % (self.ticket.id, self.ticket['summary']) 
+        projname = self.config.get('project', 'name')
+        return '[%s] #%s: %s' % (projname, self.ticket.id,
+                                 self.ticket['summary'])
 
     def get_recipients(self, tktid):
         notify_reporter = self.config.getbool('notification',
@@ -206,15 +199,13 @@
         ccrecipients = self.prev_cc
         torecipients = []
         cursor = self.db.cursor()
-        
+
         # Harvest email addresses from the cc, reporter, and owner fields
         cursor.execute("SELECT cc,reporter,owner FROM ticket WHERE id=%s",
                        (tktid,))
         row = cursor.fetchone()
         if row:
             ccrecipients += row[0] and row[0].replace(',', ' ').split() or []
-            self.reporter = row[1]
-            self.owner = row[2]
             if notify_reporter:
                 torecipients.append(row[1])
             if notify_owner:
@@ -228,27 +219,11 @@
                 torecipients.append(author)
 
         # Suppress the updater from the recipients
-        updater = None
-        cursor.execute("SELECT author FROM ticket_change WHERE ticket=%s "
-                       "ORDER BY time DESC LIMIT 1", (tktid,))
-        for updater, in cursor:
-            break
-        else:
-            cursor.execute("SELECT reporter FROM ticket WHERE id=%s",
-                           (tktid,))
-            for updater, in cursor:
-                break
-
         if not notify_updater:
-            filter_out = True
-            if notify_reporter and (updater == self.reporter):
-                filter_out = False
-            if notify_owner and (updater == self.owner):
-                filter_out = False
-            if filter_out:
-                torecipients = [r for r in torecipients if r and r != updater]
-        elif updater:
-            torecipients.append(updater)
+            cursor.execute("SELECT author FROM ticket_change WHERE ticket=%s "
+                           "ORDER BY time DESC LIMIT 1", (tktid,))
+            (updater, ) = cursor.fetchone() 
+            torecipients = [r for r in torecipients if r and r != updater]
 
         return (torecipients, ccrecipients)
 
@@ -263,14 +238,19 @@
         return msgid
 
     def send(self, torcpts, ccrcpts):
-        dest = self.reporter or 'anonymous'
         hdrs = {}
-        hdrs['Message-ID'] = self.get_message_id(dest, self.modtime)
+        always_cc = self.config['notification'].get('smtp_always_cc')
+        always_bcc = self.config['notification'].get('smtp_always_bcc')
+        dest = filter(None, torcpts) or filter(None, ccrcpts) or \
+               filter(None, [always_cc]) or filter(None, [always_bcc])
+        if not dest:
+            self.env.log.info('no recipient for a ticket notification')
+            return
+        hdrs['Message-ID'] = self.get_message_id(dest[0], self.modtime)
         hdrs['X-Trac-Ticket-ID'] = str(self.ticket.id)
         hdrs['X-Trac-Ticket-URL'] = self.ticket['link']
         if not self.newticket:
-            msgid = self.get_message_id(dest)
-            hdrs['In-Reply-To'] = msgid
-            hdrs['References'] = msgid
+            hdrs['In-Reply-To'] = self.get_message_id(dest[0])
+            hdrs['References'] = self.get_message_id(dest[0])
         NotifyEmail.send(self, torcpts, ccrcpts, hdrs)
 
diff -uNr usr/share/python-support/trac/trac/ticket/query.py /usr/share/python-support/trac/trac/ticket/query.py
--- usr/share/python-support/trac/trac/ticket/query.py	2006-12-08 11:34:03.000000000 +0100
+++ /usr/share/python-support/trac/trac/ticket/query.py	2007-07-08 17:23:47.851958727 +0200
@@ -377,7 +377,7 @@
         if req.perm.has_permission('TICKET_VIEW') and \
                 not self.env.is_component_enabled(ReportModule):
             yield ('mainnav', 'tickets',
-                   html.A('View Tickets', href=req.href.query()))
+                   html.A('Meldingen weergeven', href=req.href.query()))
 
     # IRequestHandler methods
 
@@ -485,21 +485,21 @@
     def _get_constraint_modes(self):
         modes = {}
         modes['text'] = [
-            {'name': "contains", 'value': "~"},
-            {'name': "doesn't contain", 'value': "!~"},
-            {'name': "begins with", 'value': "^"},
-            {'name': "ends with", 'value': "$"},
+            {'name': "bevat", 'value': "~"},
+            {'name': "bevat niet", 'value': "!~"},
+            {'name': "begint met", 'value': "^"},
+            {'name': "eindigt met", 'value': "$"},
             {'name': "is", 'value': ""},
-            {'name': "is not", 'value': "!"}
+            {'name': "is niet", 'value': "!"}
         ]
         modes['select'] = [
             {'name': "is", 'value': ""},
-            {'name': "is not", 'value': "!"}
+            {'name': "is niet", 'value': "!"}
         ]
         return modes
 
     def display_html(self, req, query):
-        req.hdf['title'] = 'Custom Query'
+        req.hdf['title'] = 'Meldingen weergeven'
         add_stylesheet(req, 'common/css/report.css')
         add_script(req, 'common/js/query.js')
 
diff -uNr usr/share/python-support/trac/trac/ticket/report.py /usr/share/python-support/trac/trac/ticket/report.py
--- usr/share/python-support/trac/trac/ticket/report.py	2006-10-24 03:35:04.000000000 +0200
+++ /usr/share/python-support/trac/trac/ticket/report.py	2007-05-03 20:08:06.957322514 +0200
@@ -32,6 +32,7 @@
 from trac.web.chrome import add_link, add_stylesheet, INavigationContributor
 from trac.wiki import wiki_to_html, IWikiSyntaxProvider, Formatter
 
+
 class ReportModule(Component):
 
     implements(INavigationContributor, IPermissionRequestor, IRequestHandler,
@@ -46,7 +47,7 @@
         if not req.perm.has_permission('REPORT_VIEW'):
             return
         yield ('mainnav', 'tickets',
-               html.A('View Tickets', href=req.href.report()))
+               html.A('Meldingen weergeven', href=req.href.report()))
 
     # IPermissionRequestor methods  
 
@@ -93,7 +94,7 @@
                return resp
 
         if id != -1 or action == 'new':
-            add_link(req, 'up', req.href.report(), 'Available Reports')
+            add_link(req, 'up', req.href.report(), 'Beschikbare rapporten')
 
             # Kludge: Reset session vars created by query module so that the
             # query navigation links on the ticket page don't confuse the user
@@ -387,7 +388,7 @@
                      'text/plain')
 
     def execute_report(self, req, db, id, sql, args):
-        sql, args = self.sql_sub_vars(req, sql, args, db)
+        sql, args = self.sql_sub_vars(req, sql, args)
         if not sql:
             raise TracError('Report %s has no SQL query.' % id)
         if sql.find('__group__') == -1:
@@ -430,7 +431,7 @@
     def get_var_args(self, req):
         report_args = {}
         for arg in req.args.keys():
-            if not arg.isupper():
+            if not arg == arg.upper():
                 continue
             report_args[arg] = req.args.get(arg)
 
@@ -440,9 +441,7 @@
 
         return report_args
 
-    def sql_sub_vars(self, req, sql, args, db=None):
-        if db is None:
-            db = self.env.get_db_cnx()
+    def sql_sub_vars(self, req, sql, args):
         values = []
         def add_value(aname):
             try:
@@ -453,26 +452,18 @@
             req.hdf['report.var.' + aname] = arg
             values.append(arg)
 
-        # simple parameter substitution outside literal
+        # simple parameter substitution
         def repl(match):
             add_value(match.group(1))
             return '%s'
 
-        # inside a literal break it and concatenate with the parameter
-        def repl_literal(match):
-            add_value(match.group(1))
-            return db.concat("'", "%s", "'")
-
-        var_re = re.compile("[$]([A-Z]+)")
+        var_re = re.compile("'?[$]([A-Z]+)'?")
         sql_io = StringIO()
 
         # break SQL into literals and non-literals to handle replacing
         # variables within them with query parameters
         for expr in re.split("('(?:[^']|(?:''))*')", sql):
-            if expr.startswith("'"):
-                sql_io.write(var_re.sub(repl_literal, expr))
-            else:
-                sql_io.write(var_re.sub(repl, expr))
+            sql_io.write(var_re.sub(repl, expr))
         return sql_io.getvalue(), values
 
     def _render_csv(self, req, cols, rows, sep=','):
diff -uNr usr/share/python-support/trac/trac/ticket/roadmap.py /usr/share/python-support/trac/trac/ticket/roadmap.py
--- usr/share/python-support/trac/trac/ticket/roadmap.py	2006-12-06 12:38:18.000000000 +0100
+++ /usr/share/python-support/trac/trac/ticket/roadmap.py	2007-05-24 12:07:05.565186987 +0200
@@ -87,8 +87,11 @@
     }
 
 def milestone_to_hdf(env, db, req, milestone):
+    safe_name = None
+    if milestone.exists:
+        safe_name = milestone.name.replace('/', '%2F')
     hdf = {'name': milestone.name,
-           'href': req.href.milestone(milestone.name)}
+           'href': req.href.milestone(safe_name)}
     if milestone.description:
         hdf['description_source'] = milestone.description
         hdf['description'] = wiki_to_html(milestone.description, env, req, db)
@@ -129,7 +132,7 @@
         if not req.perm.has_permission('ROADMAP_VIEW'):
             return
         yield ('mainnav', 'roadmap',
-               html.a('Roadmap', href=req.href.roadmap(), accesskey=3))
+               html.a('Planning', href=req.href.roadmap(), accesskey=3))
 
     # IPermissionRequestor methods
 
@@ -143,7 +146,7 @@
 
     def process_request(self, req):
         req.perm.assert_permission('ROADMAP_VIEW')
-        req.hdf['title'] = 'Roadmap'
+        req.hdf['title'] = 'Planning'
 
         showall = req.args.get('show') == 'all'
         req.hdf['roadmap.showall'] = showall
@@ -243,7 +246,7 @@
             if milestone.has_key('due'):
                 write_prop('BEGIN', 'VEVENT')
                 write_prop('UID', uid)
-                write_utctime('DTSTAMP', localtime(milestone['due']))
+                write_date('DTSTAMP', localtime(milestone['due']))
                 write_date('DTSTART', localtime(milestone['due']))
                 write_prop('SUMMARY', 'Milestone %s' % milestone['name'])
                 write_prop('URL', req.base_url + '/milestone/' +
@@ -289,7 +292,7 @@
     # INavigationContributor methods
 
     def get_active_navigation_item(self, req):
-        return 'roadmap'
+        return 'planning'
 
     def get_navigation_items(self, req):
         return []
@@ -306,7 +309,7 @@
 
     def get_timeline_filters(self, req):
         if req.perm.has_permission('MILESTONE_VIEW'):
-            yield ('milestone', 'Milestones')
+            yield ('milestone', 'Mijlpalen')
 
     def get_timeline_events(self, req, start, stop, filters):
         if 'milestone' in filters:
@@ -317,7 +320,7 @@
                            "WHERE completed>=%s AND completed<=%s",
                            (start, stop,))
             for completed, name, description in cursor:
-                title = Markup('Milestone <em>%s</em> completed', name)
+                title = Markup('Mijlpaal <em>%s</em> gecompleteerd', name)
                 if format == 'rss':
                     href = req.abs_href.milestone(name)
                     message = wiki_to_html(description, self.env, req, db,
@@ -339,20 +342,19 @@
             return True
 
     def process_request(self, req):
-        milestone_id = req.args.get('id')
-            
         req.perm.assert_permission('MILESTONE_VIEW')
 
         add_link(req, 'up', req.href.roadmap(), 'Roadmap')
 
         db = self.env.get_db_cnx()
-        milestone = Milestone(self.env, milestone_id, db)
+        milestone = Milestone(self.env, req.args.get('id'), db)
         action = req.args.get('action', 'view')
 
         if req.method == 'POST':
             if req.args.has_key('cancel'):
                 if milestone.exists:
-                    req.redirect(req.href.milestone(milestone.name))
+                    safe_name = milestone.name.replace('/', '%2F')
+                    req.redirect(req.href.milestone(safe_name))
                 else:
                     req.redirect(req.href.roadmap())
             elif action == 'edit':
@@ -366,9 +368,6 @@
         else:
             self._render_view(req, db, milestone)
 
-        if not milestone_id and action != 'new':
-            req.redirect(req.href.roadmap())
-
         add_stylesheet(req, 'common/css/roadmap.css')
         return 'milestone.cs', None
 
@@ -430,12 +429,13 @@
             milestone.insert()
         db.commit()
 
-        req.redirect(req.href.milestone(milestone.name))
+        safe_name = milestone.name.replace('/', '%2F')
+        req.redirect(req.href.milestone(safe_name))
 
     def _render_confirm(self, req, db, milestone):
         req.perm.assert_permission('MILESTONE_DELETE')
 
-        req.hdf['title'] = 'Milestone %s' % milestone.name
+        req.hdf['title'] = 'Mijlpaal %s' % milestone.name
         req.hdf['milestone'] = milestone_to_hdf(self.env, db, req, milestone)
         req.hdf['milestone.mode'] = 'delete'
 
@@ -447,14 +447,14 @@
     def _render_editor(self, req, db, milestone):
         if milestone.exists:
             req.perm.assert_permission('MILESTONE_MODIFY')
-            req.hdf['title'] = 'Milestone %s' % milestone.name
+            req.hdf['title'] = 'Mijlpaal %s' % milestone.name
             req.hdf['milestone.mode'] = 'edit'
             req.hdf['milestones'] = [m.name for m in
                                      Milestone.select(self.env)
                                      if m.name != milestone.name]
         else:
             req.perm.assert_permission('MILESTONE_CREATE')
-            req.hdf['title'] = 'New Milestone'
+            req.hdf['title'] = 'Nieuwe mijlpaal'
             req.hdf['milestone.mode'] = 'new'
 
         from trac.util.datefmt import get_date_format_hint, \
@@ -465,7 +465,7 @@
         req.hdf['milestone.datetime_now'] = format_datetime()
 
     def _render_view(self, req, db, milestone):
-        req.hdf['title'] = 'Milestone %s' % milestone.name
+        req.hdf['title'] = 'Mijlpaal %s' % milestone.name
         req.hdf['milestone.mode'] = 'view'
 
         req.hdf['milestone'] = milestone_to_hdf(self.env, db, req, milestone)
diff -uNr usr/share/python-support/trac/trac/ticket/web_ui.py /usr/share/python-support/trac/trac/ticket/web_ui.py
--- usr/share/python-support/trac/trac/ticket/web_ui.py	2006-11-15 22:34:40.000000000 +0100
+++ /usr/share/python-support/trac/trac/ticket/web_ui.py	2007-07-07 22:26:48.043095023 +0200
@@ -29,7 +29,7 @@
 from trac.util import get_reporter_id
 from trac.util.datefmt import format_datetime, pretty_timedelta, http_date
 from trac.util.html import html, Markup
-from trac.util.text import CRLF
+from trac.util.text import CRLF, translate
 from trac.web import IRequestHandler
 from trac.web.chrome import add_link, add_stylesheet, INavigationContributor
 from trac.wiki import wiki_to_html, wiki_to_oneliner
@@ -107,12 +107,12 @@
         if not req.perm.has_permission('TICKET_CREATE'):
             return
         yield ('mainnav', 'newticket', 
-               html.A('New Ticket', href=req.href.newticket(), accesskey=7))
+               html.A('Nieuwe melding', href=req.href.newticket(), accesskey=7))
 
     # IRequestHandler methods
 
     def match_request(self, req):
-        return re.match(r'/newticket/?$', req.path_info) is not None
+        return re.match(r'/newticket/?', req.path_info) is not None
 
     def process_request(self, req):
         req.perm.assert_permission('TICKET_CREATE')
@@ -134,7 +134,7 @@
             description = wiki_to_html(ticket['description'], self.env, req, db)
             req.hdf['newticket.description_preview'] = description
 
-        req.hdf['title'] = 'New Ticket'
+        req.hdf['title'] = 'Nieuwe melding'
         req.hdf['newticket'] = ticket.values
 
         field_names = [field['name'] for field in ticket.fields
@@ -156,7 +156,7 @@
                         'resolution'):
                 field['skip'] = True
             elif name == 'owner':
-                field['label'] = 'Assign to'
+                field['label'] = 'Toekennen aan'
                 if not req.perm.has_permission('TICKET_MODIFY'):
                     field['skip'] = True
             elif name == 'milestone':
@@ -167,6 +167,8 @@
                     if milestone.is_completed:
                         options.remove(option)
                 field['options'] = options
+
+            field['label'] = translate(self.env, field['label'])
             req.hdf['newticket.fields.' + name] = field
 
         if req.perm.has_permission('TICKET_APPEND'):
@@ -180,7 +182,7 @@
 
     def _do_create(self, req, db):
         if not req.args.get('summary'):
-            raise TracError('Tickets must contain a summary.')
+            raise TracError('ATickets must contain a summary.')
 
         ticket = Ticket(self.env, db=db)
         ticket.populate(req.args)
@@ -205,7 +207,7 @@
             req.redirect(req.href.ticket(ticket.id))
 
 
-class TicketModule(TicketModuleBase):
+class TicketMdule(TicketModuleBase):
 
     implements(INavigationContributor, IRequestHandler, ITimelineEventProvider,
                IContentConverter)
@@ -232,9 +234,9 @@
     # IContentConverter methods
 
     def get_supported_conversions(self):
-        yield ('csv', 'Comma-delimited Text', 'csv',
+        yield ('csv', 'Komma-gescheiden tekst', 'csv',
                'trac.ticket.Ticket', 'text/csv', 8)
-        yield ('tab', 'Tab-delimited Text', 'tsv',
+        yield ('tab', 'TAB-gescheiden tekst', 'tsv',
                'trac.ticket.Ticket', 'text/tab-separated-values', 8)
         yield ('rss', 'RSS Feed', 'xml',
                'trac.ticket.Ticket', 'application/rss+xml', 8)
@@ -259,7 +261,7 @@
     # IRequestHandler methods
 
     def match_request(self, req):
-        match = re.match(r'/ticket/([0-9]+)$', req.path_info)
+        match = re.match(r'/ticket/([0-9]+)', req.path_info)
         if match:
             req.args['id'] = match.group(1)
             return True
@@ -315,14 +317,14 @@
                 idx = tickets.index(str(ticket.id))
                 if idx > 0:
                     add_link(req, 'first', req.href.ticket(tickets[0]),
-                             'Ticket #%s' % tickets[0])
+                             'Melding #%s' % tickets[0])
                     add_link(req, 'prev', req.href.ticket(tickets[idx - 1]),
-                             'Ticket #%s' % tickets[idx - 1])
+                             'Melding #%s' % tickets[idx - 1])
                 if idx < len(tickets) - 1:
                     add_link(req, 'next', req.href.ticket(tickets[idx + 1]),
-                             'Ticket #%s' % tickets[idx + 1])
+                             'Melding #%s' % tickets[idx + 1])
                     add_link(req, 'last', req.href.ticket(tickets[-1]),
-                             'Ticket #%s' % tickets[-1])
+                             'Melding #%s' % tickets[-1])
                 add_link(req, 'up', req.session['query_href'])
 
         add_stylesheet(req, 'common/css/ticket.css')
@@ -339,17 +341,17 @@
 
     def get_timeline_filters(self, req):
         if req.perm.has_permission('TICKET_VIEW'):
-            yield ('ticket', 'Ticket changes')
+            yield ('ticket', 'Aanpassingen van melding')
             if self.timeline_details:
-                yield ('ticket_details', 'Ticket details', False)
+                yield ('ticket_details', 'Details van melding', False)
 
     def get_timeline_events(self, req, start, stop, filters):
         format = req.args.get('format')
 
-        status_map = {'new': ('newticket', 'created'),
-                      'reopened': ('newticket', 'reopened'),
-                      'closed': ('closedticket', 'closed'),
-                      'edit': ('editedticket', 'updated')}
+        status_map = {'new': ('newticket', 'gemaakt'),
+                      'reopened': ('newticket', 'heropend'),
+                      'closed': ('closedticket', 'gesloten'),
+                      'edit': ('editedticket', 'bijgewerkt')}
 
         href = format == 'rss' and req.abs_href or req.href
 
@@ -360,7 +362,7 @@
                     info = ''
                     if len(fields) > 0:
                         info = ', '.join(['<i>%s</i>' % f for f in \
-                                          fields.keys()]) + ' changed<br />'
+                                          fields.keys()]) + ' gewijzigd<br />'
                 else:
                     return None
             elif 'ticket' in filters:
@@ -374,11 +376,11 @@
                 return None
             kind, verb = status_map[status]
             if format == 'rss':
-                title = 'Ticket #%s (%s %s): %s' % \
-                        (id, type.lower(), verb, summary)
+                title = 'Melding #%s (%s %s): %s' % \
+                        (id, translate(self.env, type).lower(), verb, summary)
             else:
-                title = Markup('Ticket <em title="%s">#%s</em> (%s) %s by %s',
-                               summary, id, type, verb, author)
+                title = Markup('Melding <em title="%s">#%s</em> (%s) %s door %s',
+                               summary, id, translate(self.env, type), verb, author)
             ticket_href = href.ticket(id)
             if cid:
                 ticket_href += '#comment:' + cid
@@ -541,17 +543,17 @@
         internal_cnum = cnum
         if cnum and replyto: # record parent.child relationship
             internal_cnum = '%s.%s' % (replyto, cnum)
-        if ticket.save_changes(get_reporter_id(req, 'author'),
-                               req.args.get('comment'), when=now, db=db,
-                               cnum=internal_cnum):
-            db.commit()
-
-            try:
-                tn = TicketNotifyEmail(self.env)
-                tn.notify(ticket, newticket=False, modtime=now)
-            except Exception, e:
-                self.log.exception("Failure sending notification on change to "
-                                   "ticket #%s: %s" % (ticket.id, e))
+        ticket.save_changes(get_reporter_id(req, 'author'),
+                            req.args.get('comment'), when=now, db=db,
+                            cnum=internal_cnum)
+        db.commit()
+
+        try:
+            tn = TicketNotifyEmail(self.env)
+            tn.notify(ticket, newticket=False, modtime=now)
+        except Exception, e:
+            self.log.exception("Failure sending notification on change to "
+                               "ticket #%s: %s" % (ticket.id, e))
 
         fragment = cnum and '#comment:'+cnum or ''
         req.redirect(req.href.ticket(ticket.id) + fragment)
@@ -573,10 +575,6 @@
             if field['type'] in ('radio', 'select'):
                 value = ticket.values.get(field['name'])
                 options = field['options']
-                if field['name'] == 'milestone' \
-                    and not req.perm.has_permission('TICKET_ADMIN'):
-                    options = [opt for opt in options if not
-                               Milestone(self.env, opt, db=db).is_completed]
                 if value and not value in options:
                     # Current ticket value must be visible even if its not in the
                     # possible values
@@ -606,7 +604,7 @@
         def quote_original(author, original, link):
             if not 'comment' in req.args: # i.e. the comment was not yet edited
                 req.hdf['ticket.comment'] = '\n'.join(
-                    ['Replying to [%s %s]:' % (link, author)] +
+                    ['Reagerend op [%s %s]:' % (link, author)] +
                     ['> %s' % line for line in original.splitlines()] + [''])
 
         if replyto == 'description':
diff -uNr usr/share/python-support/trac/trac/Timeline.py /usr/share/python-support/trac/trac/Timeline.py
--- usr/share/python-support/trac/trac/Timeline.py	2006-10-02 18:54:42.000000000 +0200
+++ /usr/share/python-support/trac/trac/Timeline.py	2007-05-03 20:02:21.504579628 +0200
@@ -77,7 +77,7 @@
         if not req.perm.has_permission('TIMELINE_VIEW'):
             return
         yield ('mainnav', 'timeline',
-               html.A('Timeline', href=req.href.timeline(), accesskey=2))
+               html.A('Tijdslijn', href=req.href.timeline(), accesskey=2))
 
     # IPermissionRequestor methods
 
@@ -151,7 +151,7 @@
         if maxrows and len(events) > maxrows:
             del events[maxrows:]
 
-        req.hdf['title'] = 'Timeline'
+        req.hdf['title'] = 'Historie'
 
         # Get the email addresses of all known users
         email_map = {}
diff -uNr usr/share/python-support/trac/trac/util/datefmt.py /usr/share/python-support/trac/trac/util/datefmt.py
--- usr/share/python-support/trac/trac/util/datefmt.py	2006-09-13 07:22:18.000000000 +0200
+++ /usr/share/python-support/trac/trac/util/datefmt.py	2007-05-24 12:39:45.640756375 +0200
@@ -30,17 +30,17 @@
     if not time2: time2 = time.time()
     if time1 > time2:
         time2, time1 = time1, time2
-    units = ((3600 * 24 * 365, 'year',   'years'),
-             (3600 * 24 * 30,  'month',  'months'),
-             (3600 * 24 * 7,   'week',   'weeks'),
-             (3600 * 24,       'day',    'days'),
-             (3600,            'hour',   'hours'),
-             (60,              'minute', 'minutes'))
+    units = ((3600 * 24 * 365, 'jaar',   'jaren'),
+             (3600 * 24 * 30,  'maand',  'maanden'),
+             (3600 * 24 * 7,   'week',   'weken'),
+             (3600 * 24,       'dag',    'dagen'),
+             (3600,            'uur',   'uren'),
+             (60,              'minuut', 'minuten'))
     age_s = int(time2 - time1)
     if resolution and age_s < resolution:
         return ''
     if age_s < 60:
-        return '%i second%s' % (age_s, age_s != 1 and 's' or '')
+        return '%i seconde%s' % (age_s, age_s != 1 and 'n' or '')
     for u, unit, unit_plural in units:
         r = float(age_s) / float(u)
         if r >= 0.9:
@@ -102,8 +102,10 @@
 def parse_date(text):
     seconds = None
     text = text.strip()
-    for format in ['%x %X', '%x, %X', '%X %x', '%X, %x', '%x', '%c',
-                   '%b %d, %Y']:
+    # for format in ['%x %X', '%x, %X', '%X %x', '%X, %x', '%x', '%c', 
+    #               '%b %d, %Y']:
+    for format in ['%d/%m/%Y', '%Y%m%d','%d-%m-%Y',  '%x %X', '%x, %X', '%X %x', '%X, %x', '%x', '%c', 
+                   '%b %d, %Y']:        
         try:
             date = time.strptime(text, format)
             seconds = time.mktime(date)
@@ -111,5 +113,5 @@
         except ValueError:
             continue
     if seconds == None:
-        raise ValueError, '%s is not a known date format.' % text
+        raise ValueError, '%s is een ongeldige datumopmaak.' % text
     return seconds
diff -uNr usr/share/python-support/trac/trac/util/html.py /usr/share/python-support/trac/trac/util/html.py
--- usr/share/python-support/trac/trac/util/html.py	2006-11-07 14:09:23.000000000 +0100
+++ /usr/share/python-support/trac/trac/util/html.py	2007-05-03 20:08:50.158897647 +0200
@@ -465,9 +465,6 @@
 
 class Tags(object):
 
-    def __call__(self, *args):
-        return Fragment()(*args)
-
     def __getattribute__(self, name):
         return Element(name.lower())
 
diff -uNr usr/share/python-support/trac/trac/util/__init__.py /usr/share/python-support/trac/trac/util/__init__.py
--- usr/share/python-support/trac/trac/util/__init__.py	2006-08-08 11:33:10.000000000 +0200
+++ /usr/share/python-support/trac/trac/util/__init__.py	2007-05-03 20:08:50.158897647 +0200
@@ -30,7 +30,7 @@
 from trac.core import TracError
 from trac.util.html import escape, unescape, Markup, Deuglifier
 from trac.util.text import CRLF, to_utf8, to_unicode, shorten_line, \
-                           wrap, pretty_size
+                           wrap, pretty_size, translate
 from trac.util.datefmt import pretty_timedelta, format_datetime, \
                               format_date, format_time, \
                               get_date_format_hint, \
diff -uNr usr/share/python-support/trac/trac/util/text.py /usr/share/python-support/trac/trac/util/text.py
--- usr/share/python-support/trac/trac/util/text.py	2006-07-25 09:55:02.000000000 +0200
+++ /usr/share/python-support/trac/trac/util/text.py	2007-05-03 20:08:50.158897647 +0200
@@ -146,3 +146,12 @@
         size /= 1024.
 
     return '%.1f %s' % (size, units[i - 1])
+
+# -- Translation
+
+def translate(env, name, capitalize=False):
+    if capitalize:
+        return env.translations.get(name.lower().capitalize(), name.capitalize())
+    else:
+        return env.translations.get(name.lower(), name)
+
diff -uNr usr/share/python-support/trac/trac/versioncontrol/api.py /usr/share/python-support/trac/trac/versioncontrol/api.py
--- usr/share/python-support/trac/trac/versioncontrol/api.py	2006-11-16 12:20:40.000000000 +0100
+++ /usr/share/python-support/trac/trac/versioncontrol/api.py	2007-05-03 20:20:37.134738846 +0200
@@ -15,16 +15,10 @@
 # Author: Christopher Lenz <cmlenz@gmx.de>
 
 from heapq import heappop, heappush
-try:
-    import threading
-except ImportError:
-    import dummy_threading as threading
-    threading._get_ident = lambda: 0
 
 from trac.config import Option
 from trac.core import *
 from trac.perm import PermissionError
-from trac.web.api import IRequestFilter
 
 
 class IRepositoryConnector(Interface):
@@ -51,8 +45,6 @@
     It provides easy access to the configured implementation.
     """
 
-    implements(IRequestFilter)
-
     connectors = ExtensionPoint(IRepositoryConnector)
 
     repository_type = Option('trac', 'repository_type', 'svn',
@@ -61,22 +53,8 @@
         """Path to local repository""")
 
     def __init__(self):
-        self._cache = {}
-        self._lock = threading.Lock()
         self._connector = None
 
-    # IRequestFilter methods
-
-    def pre_process_request(self, req, handler):
-        from trac.web.chrome import Chrome        
-        if handler is not Chrome(self.env):
-            self.get_repository(req.authname) # triggers a sync if applicable
-        return handler
-
-    def post_process_request(self, req, template, content_type):
-        return (template, content_type)
-
-
     # Public API methods
 
     def get_repository(self, authname):
@@ -91,27 +69,8 @@
                 raise TracError('Unsupported version control system "%s"'
                                 % self.repository_type)
             self._connector = heappop(candidates)[1]
-        try:
-            self._lock.acquire()
-            tid = threading._get_ident()
-            if tid in self._cache:
-                repos = self._cache[tid]
-            else:
-                rtype, rdir = self.repository_type, self.repository_dir
-                repos = self._connector.get_repository(rtype, rdir, authname)
-                self._cache[tid] = repos
-            return repos
-        finally:
-            self._lock.release()
-
-    def shutdown(self, tid=None):
-        if tid:
-            assert tid == threading._get_ident()
-            try:
-                self._lock.acquire()
-                self._cache.pop(tid, None)
-            finally:
-                self._lock.release()
+        return self._connector.get_repository(self.repository_type,
+                                              self.repository_dir, authname)
 
 
 class NoSuchChangeset(TracError):
@@ -135,10 +94,6 @@
         """Close the connection to the repository."""
         raise NotImplementedError
 
-    def clear(self):
-        """Clear any data that may have been cached in instance properties."""
-        pass
-
     def get_changeset(self, rev):
         """Retrieve a Changeset corresponding to the  given revision `rev`."""
         raise NotImplementedError
@@ -364,9 +319,6 @@
     EDIT = 'edit'
     MOVE = 'move'
 
-    # change types which can have diff associated to them
-    DIFF_CHANGES = (EDIT, COPY, MOVE) # MERGE
-
     def __init__(self, rev, message, author, date):
         self.rev = rev
         self.message = message
diff -uNr usr/share/python-support/trac/trac/versioncontrol/cache.py /usr/share/python-support/trac/trac/versioncontrol/cache.py
--- usr/share/python-support/trac/trac/versioncontrol/cache.py	2006-11-21 18:35:50.000000000 +0100
+++ /usr/share/python-support/trac/trac/versioncontrol/cache.py	2007-05-03 20:20:37.134738846 +0200
@@ -31,16 +31,22 @@
         Repository.__init__(self, repos.name, authz, log)
         self.db = db
         self.repos = repos
-        self.sync()
+        self.synced = 0
 
     def close(self):
         self.repos.close()
 
     def get_changeset(self, rev):
+        if not self.synced:
+            self.sync()
+            self.synced = 1
         return CachedChangeset(self.repos.normalize_rev(rev), self.db,
                                self.authz)
 
     def get_changesets(self, start, stop):
+        if not self.synced:
+            self.sync()
+            self.synced = 1
         cursor = self.db.cursor()
         cursor.execute("SELECT rev FROM revision "
                        "WHERE time >= %s AND time < %s "
@@ -50,20 +56,21 @@
                 yield self.get_changeset(rev)
 
     def sync(self):
+        self.log.debug("Checking whether sync with repository is needed")
         cursor = self.db.cursor()
 
         # -- repository used for populating the cache
         cursor.execute("SELECT value FROM system WHERE name='repository_dir'")
-        for previous_repository_dir, in cursor:
-            if previous_repository_dir != self.name:
-                raise TracError("The 'repository_dir' has changed, "
-                                "a 'trac-admin resync' operation is needed.")
-            break
+        row = cursor.fetchone()
+        if row:
+            previous_repository_dir = row[0]
         else: # no 'repository_dir' stored yet, assume everything's OK
-            cursor.execute("INSERT INTO system (name,value) "
-                           "VALUES ('repository_dir',%s)", (self.name,))
+            previous_repository_dir = self.name
+
+        if self.name != previous_repository_dir:
+            raise TracError, ("The 'repository_dir' has changed, "
+                              "a 'trac-admin resync' operation is needed.")
 
-        self.repos.clear()
         youngest_stored = self.repos.get_youngest_rev_in_cache(self.db)
 
         if youngest_stored != str(self.repos.youngest_rev):
@@ -113,7 +120,7 @@
         return self.repos.oldest_rev
 
     def get_youngest_rev(self):
-        return self.repos.get_youngest_rev_in_cache(self.db)
+        return self.repos.youngest_rev
 
     def previous_rev(self, rev):
         return self.repos.previous_rev(rev)
diff -uNr usr/share/python-support/trac/trac/versioncontrol/diff.py /usr/share/python-support/trac/trac/versioncontrol/diff.py
--- usr/share/python-support/trac/trac/versioncontrol/diff.py	2006-10-18 02:55:53.000000000 +0200
+++ /usr/share/python-support/trac/trac/versioncontrol/diff.py	2007-05-03 20:20:37.134738846 +0200
@@ -104,7 +104,7 @@
     """
     # Full context produces all the opcodes
     if n is None:
-        yield list(opcodes)
+        yield opcodes
         return
 
     # Otherwise we leave at most n lines with the tag 'equal' before and after
diff -uNr usr/share/python-support/trac/trac/versioncontrol/svn_authz.py /usr/share/python-support/trac/trac/versioncontrol/svn_authz.py
--- usr/share/python-support/trac/trac/versioncontrol/svn_authz.py	2006-11-09 14:18:53.000000000 +0100
+++ /usr/share/python-support/trac/trac/versioncontrol/svn_authz.py	2007-05-03 20:20:37.134738846 +0200
@@ -32,13 +32,14 @@
         """The module prefix used in the authz_file.""")
 
 
-def SubversionAuthorizer(env, repos, authname):
+def SubversionAuthorizer(env, authname):
     authz_file = env.config.get('trac', 'authz_file')
     if not authz_file:
         return Authorizer()
 
     module_name = env.config.get('trac', 'authz_module_name')
-    return RealSubversionAuthorizer(repos, authname, module_name, authz_file)
+    db = env.get_db_cnx()
+    return RealSubversionAuthorizer(db, authname, module_name, authz_file)
 
 def parent_iter(path):
     path = path.strip('/')
@@ -63,8 +64,8 @@
     module_name = ''
     conf_authz = None
 
-    def __init__(self, repos, auth_name, module_name, cfg_file, cfg_fp=None):
-        self.repos = repos
+    def __init__(self, db, auth_name, module_name, cfg_file, cfg_fp=None):
+        self.db = db
         self.auth_name = auth_name
         self.module_name = module_name
                                 
@@ -93,9 +94,10 @@
         return 0
 
     def has_permission_for_changeset(self, rev):
-        changeset = self.repos.get_changeset(rev)
-        for path,_,_,_,_ in changeset.get_changes():
-            if self.has_permission(path):
+        cursor = self.db.cursor()
+        cursor.execute("SELECT path FROM node_change WHERE rev=%s", (rev,))
+        for row in cursor:
+            if self.has_permission(row[0]):
                 return 1
         return 0
 
diff -uNr usr/share/python-support/trac/trac/versioncontrol/svn_fs.py /usr/share/python-support/trac/trac/versioncontrol/svn_fs.py
--- usr/share/python-support/trac/trac/versioncontrol/svn_fs.py	2006-11-21 18:35:50.000000000 +0100
+++ /usr/share/python-support/trac/trac/versioncontrol/svn_fs.py	2007-05-03 20:20:37.134738846 +0200
@@ -256,13 +256,11 @@
         The repository is generally wrapped in a `CachedRepository`,
         unless `direct-svn-fs` is the specified type.
         """
-        repos = SubversionRepository(dir, None, self.log)
-        crepos = CachedRepository(self.env.get_db_cnx(), repos, None, self.log)
+        authz = None
         if authname:
-            authz = SubversionAuthorizer(self.env, crepos, authname)
-            repos.authz = crepos.authz = authz
-        return crepos
-            
+            authz = SubversionAuthorizer(self.env, authname)
+        repos = SubversionRepository(dir, authz, self.log)
+        return CachedRepository(self.env.get_db_cnx(), repos, authz, self.log)
 
 
 class SubversionRepository(Repository):
@@ -304,9 +302,9 @@
         else:
             self.scope = '/'
         assert self.scope[0] == '/'
-        self.clear()
-
-    def clear(self):
+        
+        self.log.debug("Opening subversion file-system at %s with scope %s" \
+                       % (self.path, self.scope))
         self.youngest = None
         self.oldest = None
 
@@ -335,6 +333,7 @@
         return rev
 
     def close(self):
+        self.log.debug("Closing subversion file-system at %s" % self.path)
         self.repos = None
         self.fs_ptr = None
         self.pool = None
@@ -486,7 +485,7 @@
             text_deltas = 0 # as this is anyway re-done in Diff.py...
             entry_props = 0 # "... typically used only for working copy updates"
             repos.svn_repos_dir_delta(old_root,
-                                      _to_svn(self.scope + old_path), '',
+                                      _to_svn(self.scope, old_path), '',
                                       new_root,
                                       _to_svn(self.scope + new_path),
                                       e_ptr, e_baton, authz_cb,
@@ -617,8 +616,6 @@
     def get_last_modified(self):
         date = fs.revision_prop(self.fs_ptr, self.created_rev,
                                 core.SVN_PROP_REVISION_DATE, self.pool())
-        if not date:
-            return 0
         return core.svn_time_from_cstring(date, self.pool()) / 1000000
 
     def _get_prop(self, name):
@@ -636,10 +633,7 @@
         message = self._get_prop(core.SVN_PROP_REVISION_LOG)
         author = self._get_prop(core.SVN_PROP_REVISION_AUTHOR)
         date = self._get_prop(core.SVN_PROP_REVISION_DATE)
-        if date:
-            date = core.svn_time_from_cstring(date, self.pool()) / 1000000
-        else:
-            date = 0
+        date = core.svn_time_from_cstring(date, self.pool()) / 1000000
         Changeset.__init__(self, rev, message, author, date)
 
     def get_changes(self):
diff -uNr usr/share/python-support/trac/trac/versioncontrol/web_ui/browser.py /usr/share/python-support/trac/trac/versioncontrol/web_ui/browser.py
--- usr/share/python-support/trac/trac/versioncontrol/web_ui/browser.py	2006-08-16 16:13:23.000000000 +0200
+++ /usr/share/python-support/trac/trac/versioncontrol/web_ui/browser.py	2007-07-08 17:19:53.723873771 +0200
@@ -66,7 +66,7 @@
         if not req.perm.has_permission('BROWSER_VIEW'):
             return
         yield ('mainnav', 'browser',
-               html.A('Browse Source', href=req.href.browser()))
+               html.A('Bronbestanden', href=req.href.browser()))
 
     # IPermissionRequestor methods
 
diff -uNr usr/share/python-support/trac/trac/versioncontrol/web_ui/changeset.py /usr/share/python-support/trac/trac/versioncontrol/web_ui/changeset.py
--- usr/share/python-support/trac/trac/versioncontrol/web_ui/changeset.py	2006-11-09 22:35:12.000000000 +0100
+++ /usr/share/python-support/trac/trac/versioncontrol/web_ui/changeset.py	2007-07-07 22:30:10.606026949 +0200
@@ -33,8 +33,9 @@
 from trac.util.datefmt import format_datetime, pretty_timedelta
 from trac.util.html import html, escape, unescape, Markup
 from trac.util.text import unicode_urlencode, shorten_line, CRLF
-from trac.versioncontrol import Changeset, Node, NoSuchChangeset
+from trac.versioncontrol import Changeset, Node
 from trac.versioncontrol.diff import get_diff_options, hdf_diff, unified_diff
+from trac.versioncontrol.svn_authz import SubversionAuthorizer
 from trac.versioncontrol.web_ui.util import render_node_property
 from trac.web import IRequestHandler
 from trac.web.chrome import INavigationContributor, add_link, add_stylesheet
@@ -78,7 +79,7 @@
 
     max_diff_files = IntOption('changeset', 'max_diff_files', 0,
         """Maximum number of modified files for which the changeset view will
-        attempt to show the diffs inlined (''since 0.10'').""")
+        attempt to show the diffs inlined (''since 0.10'')."""),
 
     max_diff_bytes = IntOption('changeset', 'max_diff_bytes', 10000000,
         """Maximum total size in bytes of the modified files (their old size
@@ -154,12 +155,12 @@
         repos = self.env.get_repository(req.authname)
         new_path = repos.normalize_path(new_path)
         new = repos.normalize_rev(new)
-
-        repos.authz.assert_permission_for_changeset(new)
-
         old_path = repos.normalize_path(old_path or new_path)
         old = repos.normalize_rev(old or new)
 
+        authzperm = SubversionAuthorizer(self.env, req.authname)
+        authzperm.assert_permission_for_changeset(new)
+
         if old_path == new_path and old == new: # revert to Changeset
             old_path = old = None
 
@@ -304,9 +305,9 @@
 
             def _changeset_title(rev):
                 if restricted:
-                    return 'Changeset %s for %s' % (rev, path)
+                    return 'Wijziging %s voor %s' % (rev, path)
                 else:
-                    return 'Changeset %s' % rev
+                    return 'Wijziging %s' % rev
 
             title = _changeset_title(rev)
             properties = []
@@ -335,7 +336,7 @@
                         prev_path = prev_rev = None
                 else:
                     add_link(req, 'first', req.href.changeset(oldest_rev),
-                             'Changeset %s' % oldest_rev)
+                             'Wijziging %s' % oldest_rev)
                     prev_path = diff.old_path
                     prev_rev = repos.previous_rev(chgset.rev)
                     if prev_rev:
@@ -347,13 +348,10 @@
                 if restricted:
                     next_rev = repos.next_rev(chgset.rev, path)
                     if next_rev:
-                        if repos.has_node(path, next_rev):
-                            next_href = req.href.changeset(next_rev, path)
-                        else: # must be a 'D'elete or 'R'ename, show full cset
-                            next_href = req.href.changeset(next_rev)
+                        next_href = req.href.changeset(next_rev, path)
                 else:
                     add_link(req, 'last', req.href.changeset(youngest_rev),
-                             'Changeset %s' % youngest_rev)
+                             'Wijziging %s' % youngest_rev)
                     next_rev = repos.next_rev(chgset.rev)
                     if next_rev:
                         next_href = req.href.changeset(next_rev)
@@ -462,8 +460,8 @@
                         break
                 if context < 0:
                     context = None
-                tabwidth = self.config['diff'].getint('tab_width') or \
-                           self.config['mimeviewer'].getint('tab_width', 8)
+                tabwidth = self.config['diff'].getint('tab_width',
+                                self.config['mimeviewer'].getint('tab_width'))
                 return hdf_diff(old_content.splitlines(),
                                 new_content.splitlines(),
                                 context, tabwidth,
@@ -477,7 +475,7 @@
             diff_bytes = diff_files = 0
             if self.max_diff_bytes or self.max_diff_files:
                 for old_node, new_node, kind, change in get_changes():
-                    if change in Changeset.DIFF_CHANGES and kind == Node.FILE:
+                    if change == Changeset.EDIT and kind == Node.FILE:
                         diff_files += 1
                         diff_bytes += _estimate_changes(old_node, new_node)
             show_diffs = (not self.max_diff_files or \
@@ -491,7 +489,7 @@
         idx = 0
         for old_node, new_node, kind, change in get_changes():
             show_entry = change != Changeset.EDIT
-            if change in Changeset.DIFF_CHANGES and \
+            if change in (Changeset.EDIT, Changeset.COPY, Changeset.MOVE) and \
                    req.perm.has_permission('FILE_VIEW'):
                 assert old_node and new_node
                 props = _prop_changes(old_node, new_node)
@@ -507,7 +505,7 @@
                         show_entry = True
             if show_entry or not show_diffs:
                 info = _change_info(old_node, new_node, change)
-                if change in Changeset.DIFF_CHANGES and not show_diffs:
+                if change == Changeset.EDIT and not show_diffs:
                     if chgset:
                         diff_href = req.href.changeset(new_node.rev,
                                                        new_node.path)
@@ -644,7 +642,7 @@
                     shortlog = shorten_line(message)
 
                 if format == 'rss':
-                    title = Markup('Changeset [%s]: %s', chgset.rev, shortlog)
+                    title = Markup('Wijziging [%s]: %s', chgset.rev, shortlog)
                     href = req.abs_href.changeset(chgset.rev)
                     if wiki_format:
                         message = wiki_to_html(message, self.env, req, db,
@@ -652,7 +650,7 @@
                     else:
                         message = html.PRE(message)
                 else:
-                    title = Markup('Changeset <em>[%s]</em> by %s', chgset.rev,
+                    title = Markup('Wijziging <em>[%s]</em> door %s', chgset.rev,
                                    chgset.author)
                     href = req.href.changeset(chgset.rev)
 
@@ -711,12 +709,14 @@
             rev, path = chgset[:sep], chgset[sep:]
         else:
             rev, path = chgset, None
-        try:
-            changeset = self.env.get_repository().get_changeset(rev)
+        cursor = formatter.db.cursor()
+        cursor.execute('SELECT message FROM revision WHERE rev=%s', (rev,))
+        row = cursor.fetchone()
+        if row:
             return html.A(label, class_="changeset",
-                          title=shorten_line(changeset.message),
+                          title=shorten_line(row[0]),
                           href=formatter.href.changeset(rev, path))
-        except NoSuchChangeset:
+        else:
             return html.A(label, class_="missing changeset",
                           href=formatter.href.changeset(rev, path),
                           rel="nofollow")
@@ -750,19 +750,19 @@
 
     def get_search_filters(self, req):
         if req.perm.has_permission('CHANGESET_VIEW'):
-            yield ('changeset', 'Changesets')
+            yield ('changeset', 'Wijzigingen')
 
     def get_search_results(self, req, terms, filters):
         if not 'changeset' in filters:
             return
-        repos = self.env.get_repository(req.authname)
+        authzperm = SubversionAuthorizer(self.env, req.authname)
         db = self.env.get_db_cnx()
         sql, args = search_to_sql(db, ['message', 'author'], terms)
         cursor = db.cursor()
         cursor.execute("SELECT rev,time,author,message "
                        "FROM revision WHERE " + sql, args)
         for rev, date, author, log in cursor:
-            if not repos.authz.has_permission_for_changeset(rev):
+            if not authzperm.has_permission_for_changeset(rev):
                 continue
             yield (req.href.changeset(rev),
                    '[%s]: %s' % (rev, shorten_line(log)),
@@ -792,8 +792,9 @@
         old_path = repos.normalize_path(old_path)
         old_rev = repos.normalize_rev(old_rev)
 
-        repos.authz.assert_permission_for_changeset(new_rev)
-        repos.authz.assert_permission_for_changeset(old_rev)
+        authzperm = SubversionAuthorizer(self.env, req.authname)
+        authzperm.assert_permission_for_changeset(new_rev)
+        authzperm.assert_permission_for_changeset(old_rev)
 
         # -- prepare rendering
         req.hdf['anydiff'] = {
diff -uNr usr/share/python-support/trac/trac/web/api.py /usr/share/python-support/trac/trac/web/api.py
--- usr/share/python-support/trac/trac/web/api.py	2006-11-13 12:41:07.000000000 +0100
+++ /usr/share/python-support/trac/trac/web/api.py	2007-05-03 20:08:26.938050927 +0200
@@ -127,7 +127,6 @@
     authname = None
     perm = None
     session = None
-    form_token = None
 
     def __init__(self, environ, start_response):
         """Create the request wrapper.
@@ -171,15 +170,14 @@
         args = _RequestArgs()
 
         fp = self.environ['wsgi.input']
-
-        # Avoid letting cgi.FieldStorage consume the input stream when the
-        # request does not contain form data
         ctype = self.get_header('Content-Type')
         if ctype:
+            # Avoid letting cgi.FieldStorage consume the input stream when the
+            # request does not contain form data
             ctype, options = cgi.parse_header(ctype)
-        if ctype not in ('application/x-www-form-urlencoded',
-                         'multipart/form-data'):
-            fp = StringIO('')
+            if ctype not in ('application/x-www-form-urlencoded',
+                             'multipart/form-data'):
+                fp = StringIO('')
 
         fs = cgi.FieldStorage(fp, environ=self.environ, keep_blank_values=True)
         if fs.list:
@@ -352,10 +350,7 @@
             content_type = 'text/plain'
             data = str(self.hdf)
         else:
-            form_token = None
-            if content_type in ('text/html', 'application/xhtml+xml'):
-                form_token = self.form_token
-            data = self.hdf.render(template, form_token)
+            data = self.hdf.render(template)
 
         self.send_response(status)
         self.send_header('Cache-control', 'must-revalidate')
diff -uNr usr/share/python-support/trac/trac/web/auth.py /usr/share/python-support/trac/trac/web/auth.py
--- usr/share/python-support/trac/trac/web/auth.py	2006-11-07 14:09:23.000000000 +0100
+++ /usr/share/python-support/trac/trac/web/auth.py	2007-07-07 21:22:41.637625828 +0200
@@ -18,12 +18,7 @@
     from base64 import b64decode
 except ImportError:
     from base64 import decodestring as b64decode
-try:
-    import threading
-except ImportError:
-    import dummy_threading as threading
 import md5
-import os
 import re
 import sys
 import time
@@ -83,7 +78,7 @@
 
     def get_navigation_items(self, req):
         if req.authname and req.authname != 'anonymous':
-            yield ('metanav', 'login', 'logged in as %s' % req.authname)
+            yield ('metanav', 'login', 'aangemeld als %s' % req.authname)
             yield ('metanav', 'logout',
                    html.A('Logout', href=req.href.logout()))
         else:
@@ -118,19 +113,14 @@
         problems on installations authenticating against Windows which is not
         case sensitive regarding user names and domain names
         """
-        if not req.remote_user:
-            raise TracError(html("Authentication information not available. "
-                                 "Please refer to the ",
-                                 html.a('installation documentation',
-                                        title="Configuring Authentication",
-                                        href=req.href.wiki('TracInstall') +
-                                        "#ConfiguringAuthentication"), "."))
+        assert req.remote_user, 'Authentication information not available.'
+
         remote_user = req.remote_user
         if self.ignore_case:
             remote_user = remote_user.lower()
 
         assert req.authname in ('anonymous', remote_user), \
-               'Already logged in as %s.' % req.authname
+               'Al aangemeld als %s.' % req.authname
 
         cookie = hex_entropy()
         db = self.env.get_db_cnx()
@@ -204,36 +194,19 @@
         raise NotImplementedError
 
 
-class PasswordFileAuthentication(HTTPAuthentication):
-    def __init__(self, filename):
-        self.filename = filename
-        self.mtime = os.stat(filename).st_mtime
-        self.load(self.filename)
-        self._lock = threading.Lock()
-
-    def check_reload(self):
-        self._lock.acquire()
-        try:
-            mtime = os.stat(self.filename).st_mtime
-            if mtime > self.mtime:
-                self.mtime = mtime
-                self.load(self.filename)
-        finally:
-            self._lock.release()
-
-class BasicAuthentication(PasswordFileAuthentication):
+class BasicAuthentication(HTTPAuthentication):
 
     def __init__(self, htpasswd, realm):
+        self.hash = {}
         self.realm = realm
         try:
             import crypt
             self.crypt = crypt.crypt
         except ImportError:
             self.crypt = None
-        PasswordFileAuthentication.__init__(self, htpasswd)
+        self.load(htpasswd)
 
     def load(self, filename):
-        self.hash = {}
         fd = open(filename, 'r')
         for line in fd:
             line = line.strip()
@@ -255,7 +228,6 @@
             print >> sys.stderr, "Warning: found no users in file:", filename
 
     def test(self, user, password):
-        self.check_reload()
         the_hash = self.hash.get(user)
         if the_hash is None:
             return False
@@ -281,21 +253,21 @@
                          % self.realm)])('')
 
 
-class DigestAuthentication(PasswordFileAuthentication):
+class DigestAuthentication(HTTPAuthentication):
     """A simple HTTP digest authentication implementation (RFC 2617)."""
 
     MAX_NONCES = 100
 
     def __init__(self, htdigest, realm):
         self.active_nonces = []
+        self.hash = {}
         self.realm = realm
-        PasswordFileAuthentication.__init__(self, htdigest)
+        self.load_htdigest(htdigest, realm)
 
-    def load(self, filename):
+    def load_htdigest(self, filename, realm):
         """Load account information from apache style htdigest files, only
         users from the specified realm are used
         """
-        self.hash = {}
         fd = open(filename, 'r')
         for line in fd.readlines():
             line = line.strip()
@@ -307,10 +279,10 @@
                 print >>sys.stderr, 'Warning: invalid digest line in %s: %s' \
                                     % (filename, line)
                 continue
-            if r == self.realm:
+            if r == realm:
                 self.hash[u] = a1
         if self.hash == {}:
-            print >> sys.stderr, "Warning: found no users in realm:", self.realm
+            print >> sys.stderr, "Warning: found no users in realm:", realm
         
     def parse_auth_header(self, authorization):
         values = {}
@@ -350,7 +322,6 @@
                 self.send_auth_request(environ, start_response)
                 return None
         # Unknown user?
-        self.check_reload()
         if not self.hash.has_key(auth['username']):
             self.send_auth_request(environ, start_response)
             return None
diff -uNr usr/share/python-support/trac/trac/web/chrome.py /usr/share/python-support/trac/trac/web/chrome.py
--- usr/share/python-support/trac/trac/web/chrome.py	2006-09-11 09:11:49.000000000 +0200
+++ /usr/share/python-support/trac/trac/web/chrome.py	2007-05-03 20:08:26.938050927 +0200
@@ -277,7 +277,7 @@
         # HTML <head> links
         add_link(req, 'start', req.href.wiki())
         add_link(req, 'search', req.href.search())
-        add_link(req, 'help', req.href.wiki('TracGuide'))
+        add_link(req, 'help', req.href.wiki('hulp'))
         add_stylesheet(req, 'common/css/trac.css')
         add_script(req, 'common/js/trac.js')
 
diff -uNr usr/share/python-support/trac/trac/web/clearsilver.py /usr/share/python-support/trac/trac/web/clearsilver.py
--- usr/share/python-support/trac/trac/web/clearsilver.py	2006-11-13 12:41:07.000000000 +0100
+++ /usr/share/python-support/trac/trac/web/clearsilver.py	2007-05-03 20:08:26.938050927 +0200
@@ -14,8 +14,6 @@
 #
 # Author: Christopher Lenz <cmlenz@gmx.de>
 
-from HTMLParser import HTMLParser
-
 from trac.core import TracError
 from trac.util.html import Markup, Fragment, escape
 from trac.util.text import to_unicode
@@ -276,7 +274,7 @@
         cs.parseStr(string)
         return cs
 
-    def render(self, template, form_token=None):
+    def render(self, template):
         """Render the HDF using the given template.
 
         The template parameter can be either an already parse neo_cs.CS
@@ -288,60 +286,7 @@
             import neo_cs
             template = neo_cs.CS(self.hdf)
             template.parseFile(filename)
-
-        if form_token:
-            from cStringIO import StringIO
-            out = StringIO()
-            injector = FormTokenInjector(form_token, out)
-            injector.feed(template.render())
-            return out.getvalue()
-        else:
-            return template.render()
-
-
-class FormTokenInjector(HTMLParser):
-    """Identify and protect forms from CSRF attacks
-
-    This filter works by adding a hidden input field to all POST forms.
-    """
-    def __init__(self, form_token, out):
-        HTMLParser.__init__(self)
-        self.out = out
-        self.token = form_token
-
-    def handle_starttag(self, tag, attrs):
-        self.out.write(self.get_starttag_text())
-        if tag.lower() == 'form':
-            for name, value in attrs:
-                if name.lower() == 'method' and value.lower() == 'post':
-                    self.out.write('<div><input type="hidden" '
-                                   ' name="__FORM_TOKEN" value="%s" /></div>'
-                                   % self.token)
-                    break
-
-    def handle_startendtag(self, tag, attrs):
-        self.out.write(self.get_starttag_text())
-
-    def handle_charref(self, name):
-        self.out.write('&#%s;' % name)
-
-    def handle_entityref(self, name):
-        self.out.write('&%s;' % name)
-
-    def handle_comment(self, data):
-        self.out.write('<!--%s-->' % data)
-
-    def handle_decl(self, data):
-        self.out.write('<!%s>' % data)
-
-    def handle_pi(self, data):
-        self.out.write('<?%s>' % data)
-
-    def handle_data(self, data):
-        self.out.write(data)
-
-    def handle_endtag(self, tag):
-        self.out.write('</' + tag + '>')
+        return template.render()
 
 
 if __name__ == '__main__':
diff -uNr usr/share/python-support/trac/trac/web/main.py /usr/share/python-support/trac/trac/web/main.py
--- usr/share/python-support/trac/trac/web/main.py	2006-12-01 13:40:48.000000000 +0100
+++ /usr/share/python-support/trac/trac/web/main.py	2007-05-03 20:08:26.948051291 +0200
@@ -16,21 +16,20 @@
 # Author: Christopher Lenz <cmlenz@gmx.de>
 #         Matthew Good <trac@matt-good.net>
 
-import cgi
-import dircache
 import locale
 import os
 import sys
+import dircache
 import urllib
 
 from trac.config import ExtensionOption, OrderedExtensionsOption
 from trac.core import *
 from trac.env import open_environment
 from trac.perm import PermissionCache, NoPermissionCache, PermissionError
-from trac.util import reversed, get_last_traceback, hex_entropy
+from trac.util import reversed, get_last_traceback
 from trac.util.datefmt import format_datetime, http_date
 from trac.util.html import Markup
-from trac.util.text import to_unicode
+from trac.util.text import to_unicode, translate
 from trac.web.api import *
 from trac.web.chrome import Chrome
 from trac.web.clearsilver import HDFWrapper
@@ -136,7 +135,7 @@
                                       IRequestHandler, 'WikiModule',
         """Name of the component that handles requests to the base URL.
         
-        Options include `TimelineModule`, `RoadmapModule`, `BrowserModule`,
+        Options include `TimeLineModule`, `RoadmapModule`, `BrowserModule`,
         `QueryModule`, `ReportModule` and `NewticketModule` (''since 0.9'').""")
 
     # Public API
@@ -164,8 +163,6 @@
         # Select the component that should handle the request
         chosen_handler = None
         early_error = None
-        req.authname = 'anonymous'
-        req.perm = NoPermissionCache()
         try:
             if not req.path_info or req.path_info == '/':
                 chosen_handler = self.default_handler
@@ -175,19 +172,6 @@
                         chosen_handler = handler
                         break
 
-            # Attach user information to the request early, so that
-            # the IRequestFilter can see it while preprocessing
-            if not getattr(chosen_handler, 'anonymous_request', False):
-                try:
-                    req.authname = self.authenticate(req)
-                    req.perm = PermissionCache(self.env, req.authname)
-                    req.session = Session(self.env, req)
-                    req.form_token = self._get_form_token(req)
-                except:
-                    req.authname = 'anonymous'
-                    req.perm = NoPermissionCache()
-                    early_error = sys.exc_info()
-
             chosen_handler = self._pre_process_request(req, chosen_handler)
         except:
             early_error = sys.exc_info()
@@ -197,6 +181,21 @@
                                         req.path_info),
                            None, None)
 
+        # Attach user information to the request
+        anonymous_request = getattr(chosen_handler, 'anonymous_request',
+                                    False)
+        if not anonymous_request:
+            try:
+                req.authname = self.authenticate(req)
+                req.perm = PermissionCache(self.env, req.authname)
+                req.session = Session(self.env, req)
+            except:
+                anonymous_request = True
+                early_error = sys.exc_info()
+        if anonymous_request:
+            req.authname = 'anonymous'
+            req.perm = NoPermissionCache()
+
         # Prepare HDF for the clearsilver template
         try:
             use_template = getattr(chosen_handler, 'use_template', True)
@@ -221,42 +220,31 @@
         # Process the request and render the template
         try:
             try:
-                # Protect against CSRF attacks: we validate the form token for
-                # all POST requests with a content-type corresponding to form
-                # submissions
-                if req.method == 'POST':
-                    ctype = req.get_header('Content-Type')
-                    if ctype:
-                        ctype, options = cgi.parse_header(ctype)
-                    if ctype in ('application/x-www-form-urlencoded',
-                                 'multipart/form-data') and \
-                            req.args.get('__FORM_TOKEN') != req.form_token:
-                        raise HTTPBadRequest('Missing or invalid form token. '
-                                             'Do you have cookies enabled?')
-
-                resp = chosen_handler.process_request(req)
-                if resp:
-                    template, content_type = self._post_process_request(req,
-                                                                        *resp)
-                    # Give the session a chance to persist changes
-                    if req.session:
-                        req.session.save()
-                    req.display(template, content_type or 'text/html')
-                else:
-                    self._post_process_request(req)
-            except RequestDone:
-                raise
-            except:
-                err = sys.exc_info()
                 try:
-                    self._post_process_request(req)
-                except Exception, e:
-                    self.log.exception(e)
-                raise err[0], err[1], err[2]
-        except PermissionError, e:
-            raise HTTPForbidden(to_unicode(e))
-        except TracError, e:
-            raise HTTPInternalError(e.message)
+                    resp = chosen_handler.process_request(req)
+                    if resp:
+                        template, content_type = \
+                                  self._post_process_request(req, *resp)
+                        req.display(template, content_type or 'text/html')
+                    else:
+                        self._post_process_request(req)
+                except RequestDone:
+                    raise
+                except:
+                    err = sys.exc_info()
+                    try:
+                        self._post_process_request(req)
+                    except Exception, e:
+                        self.log.exception(e)
+                    raise err[0], err[1], err[2]
+            except PermissionError, e:
+                raise HTTPForbidden(to_unicode(e))
+            except TracError, e:
+                raise HTTPInternalError(e.message)
+        finally:
+            # Give the session a chance to persist changes
+            if req.session:
+                req.session.save()
 
     def _pre_process_request(self, req, chosen_handler):
         for f in self.filters:
@@ -269,24 +257,6 @@
                                                             content_type)
         return template, content_type
 
-    def _get_form_token(self, req):
-        """Used to protect against CSRF.
-
-        The 'form_token' is strong shared secret stored in a user cookie.
-        By requiring that every POST form to contain this value we're able to
-        protect against CSRF attacks. Since this value is only known by the
-        user and not by an attacker.
-        
-        If the the user does not have a `trac_form_token` cookie a new
-        one is generated.
-        """
-        if req.incookie.has_key('trac_form_token'):
-            return req.incookie['trac_form_token'].value
-        else:
-            req.outcookie['trac_form_token'] = hex_entropy(24)
-            req.outcookie['trac_form_token']['path'] = req.base_path
-            return req.outcookie['trac_form_token'].value
-        
 
 def dispatch_request(environ, start_response):
     """Main entry point for the Trac web interface.
@@ -373,8 +343,7 @@
                                'options "TracEnv" or "TracEnvParentDir" are '
                                'missing. Trac requires one of these options '
                                'to locate the Trac environment(s).')
-    run_once = environ['wsgi.run_once']
-    env = _open_environment(env_path, run_once=run_once)
+    env = _open_environment(env_path, run_once=environ['wsgi.run_once'])
 
     if env.base_url:
         environ['trac.base_url'] = env.base_url
@@ -389,7 +358,7 @@
                 pass
             return req._response or []
         finally:
-            if not run_once:
+            if environ.get('wsgi.multithread', False):
                 env.shutdown(threading._get_ident())
 
     except HTTPException, e:
diff -uNr usr/share/python-support/trac/trac/web/modpython_frontend.py /usr/share/python-support/trac/trac/web/modpython_frontend.py
--- usr/share/python-support/trac/trac/web/modpython_frontend.py	2006-10-24 11:54:48.000000000 +0200
+++ /usr/share/python-support/trac/trac/web/modpython_frontend.py	2007-05-03 20:08:26.948051291 +0200
@@ -33,8 +33,8 @@
     def read(self, size=-1):
         return self.req.read(size)
 
-    def readline(self, size=-1):
-        return self.req.readline(size)
+    def readline(self):
+        return self.req.readline()
 
     def readlines(self, hint=-1):
         return self.req.readlines(hint)
diff -uNr usr/share/python-support/trac/trac/web/standalone.py /usr/share/python-support/trac/trac/web/standalone.py
--- usr/share/python-support/trac/trac/web/standalone.py	2006-11-07 14:11:39.000000000 +0100
+++ /usr/share/python-support/trac/trac/web/standalone.py	2007-05-03 20:08:26.948051291 +0200
@@ -99,10 +99,6 @@
 
     server_version = 'tracd/' + VERSION
 
-    def address_string(self):
-        # Disable reverse name lookups
-        return self.client_address[:2][0]
-
 
 def main():
     from optparse import OptionParser, OptionValueError
diff -uNr usr/share/python-support/trac/trac/wiki/api.py /usr/share/python-support/trac/trac/wiki/api.py
--- usr/share/python-support/trac/trac/wiki/api.py	2006-12-09 01:10:24.000000000 +0100
+++ /usr/share/python-support/trac/trac/wiki/api.py	2007-05-03 20:08:56.729137258 +0200
@@ -230,9 +230,8 @@
 
     # IWikiSyntaxProvider methods
 
-    XML_NAME = r"[\w:](?<!\d)(?:[\w:.-]*[\w-])?"
-    # See http://www.w3.org/TR/REC-xml/#id,
-    # here adapted to exclude terminal "." and ":" characters
+    XML_NAME = r"[\w:](?<!\d)(?:[\w:.-]*?[\w:-])*"
+    # See http://www.w3.org/TR/REC-xml/#id, here adapted to exclude terminal "."
 
     def format_page_name(self, page):
         if self.split_page_names:
@@ -244,7 +243,7 @@
         wiki_page_name = (
             r"[A-Z][a-z]+(?:[A-Z][a-z]*[a-z/])+" # wiki words
             r"(?:#%s)?" % self.XML_NAME + # optional fragment id
-            r"(?=:(?:\Z|\s)|[^:a-zA-Z]|\s|\Z)" # what should follow it
+            r"(?=:?\Z|:?\s|[.,;!?\)}\'\"\]])" # what should follow it
             )
         
         # Regular WikiPageNames
diff -uNr usr/share/python-support/trac/trac/wiki/formatter.py /usr/share/python-support/trac/trac/wiki/formatter.py
--- usr/share/python-support/trac/trac/wiki/formatter.py	2006-10-22 00:07:46.000000000 +0200
+++ /usr/share/python-support/trac/trac/wiki/formatter.py	2007-05-03 20:08:56.729137258 +0200
@@ -164,7 +164,7 @@
 
     QUOTED_STRING = r"'[^']+'|\"[^\"]+\""
 
-    SHREF_TARGET_FIRST = r"[a-zA-Z0-9/?!#@]" # we don't want "_"
+    SHREF_TARGET_FIRST = r"[\w/?!#@]"
     SHREF_TARGET_MIDDLE = r"(?:\|(?=[^|\s])|[^|<>\s])"
     SHREF_TARGET_LAST = r"[a-zA-Z0-9/=]" # we don't want "_"
 
@@ -214,9 +214,9 @@
         #  * list
         r"(?P<list>^(?P<ldepth>\s+)(?:[-*]|\d+\.|[a-zA-Z]\.|[ivxIVX]{1,5}\.) )",
         # definition:: 
-        r"(?P<definition>^\s+((?:%s[^%s]*%s|%s.*?%s|[^%s%s:]|:[^:])+::)(?:\s+|$))"
-        % (INLINE_TOKEN, INLINE_TOKEN, INLINE_TOKEN,
-           STARTBLOCK_TOKEN, ENDBLOCK_TOKEN, INLINE_TOKEN, STARTBLOCK[0]),
+        r"(?P<definition>^\s+((?:%s.*?%s|%s.*?%s|[^%s%s])+?::)(?:\s+|$))"
+        % (INLINE_TOKEN, INLINE_TOKEN, STARTBLOCK_TOKEN, ENDBLOCK_TOKEN,
+           INLINE_TOKEN, STARTBLOCK[0]),
         # (leading space)
         r"(?P<indent>^(?P<idepth>\s+)(?=\S))",
         # || table ||
diff -uNr usr/share/python-support/trac/trac/wiki/intertrac.py /usr/share/python-support/trac/trac/wiki/intertrac.py
--- usr/share/python-support/trac/trac/wiki/intertrac.py	2006-10-11 07:03:13.000000000 +0200
+++ /usr/share/python-support/trac/trac/wiki/intertrac.py	2007-05-03 20:08:56.729137258 +0200
@@ -61,9 +61,8 @@
     def render_macro(self, req, name, content):
         intertracs = {}
         for key, value in self.config.options('intertrac'):
-            idx = key.rfind('.') # rsplit only in 2.4
-            if idx > 0: # 0 itself doesn't help much: .xxx = ...
-                prefix, attribute = key[:idx], key[idx+1:]
+            if '.' in key:
+                prefix, attribute = key.split('.', 1)
                 intertrac = intertracs.setdefault(prefix, {})
                 intertrac[attribute] = value
             else:
diff -uNr usr/share/python-support/trac/trac/wiki/macros.py /usr/share/python-support/trac/trac/wiki/macros.py
--- usr/share/python-support/trac/trac/wiki/macros.py	2006-10-24 10:12:48.000000000 +0200
+++ /usr/share/python-support/trac/trac/wiki/macros.py	2007-05-03 20:08:56.729137258 +0200
@@ -125,13 +125,10 @@
         return html.DIV(
             [html.H3(date) +
              html.UL([html.LI(
-            html.A(wiki.format_page_name(name), href=req.href.wiki(name)),
-            ' ',
-            version > 1 and 
+            html.A(wiki.format_page_name(name), href=req.href.wiki(name)), ' ',
             html.SMALL('(', html.A('diff',
                                    href=req.href.wiki(name, action='diff',
-                                                      version=version)), ')') \
-            or None)
+                                                      version=version)), ')'))
                       for name, version in entries])
              for date, entries in entries_per_date])
 
diff -uNr usr/share/python-support/trac/trac/wiki/web_ui.py /usr/share/python-support/trac/trac/wiki/web_ui.py
--- usr/share/python-support/trac/trac/wiki/web_ui.py	2006-11-11 16:05:36.000000000 +0100
+++ /usr/share/python-support/trac/trac/wiki/web_ui.py	2007-05-03 20:08:56.729137258 +0200
@@ -67,7 +67,7 @@
         yield ('mainnav', 'wiki',
                html.A('Wiki', href=req.href.wiki(), accesskey=1))
         yield ('metanav', 'help',
-               html.A('Help/Guide', href=req.href.wiki('TracGuide'),
+               html.A('Hulp', href=req.href.wiki('hulp'),
                       accesskey=6))
 
     # IPermissionRequestor methods
@@ -127,7 +127,6 @@
         elif action == 'history':
             self._render_history(req, db, page)
         else:
-            req.perm.assert_permission('WIKI_VIEW')            
             format = req.args.get('format')
             if format:
                 Mimeview(self.env).send_converted(req, 'text/x-trac-wiki',
@@ -142,7 +141,7 @@
 
     def get_timeline_filters(self, req):
         if req.perm.has_permission('WIKI_VIEW'):
-            yield ('wiki', 'Wiki changes')
+            yield ('wiki', 'Wijzigingen in Wiki')
 
     def get_timeline_events(self, req, start, stop, filters):
         if 'wiki' in filters:
@@ -155,7 +154,7 @@
                            "FROM wiki WHERE time>=%s AND time<=%s",
                            (start, stop))
             for t,name,comment,author,version in cursor:
-                title = Markup('<em>%s</em> edited by %s',
+                title = Markup('<em>%s</em> bewerkt door %s',
                                wiki.format_page_name(name), author)
                 diff_link = html.A('diff', href=href.wiki(name, action='diff',
                                                           version=version))
@@ -170,6 +169,8 @@
                 yield 'wiki', href.wiki(name), title, t, author, comment
 
             # Attachments
+            def display(id):
+                return Markup('ticket ', html.EM('#', id))
             att = AttachmentModule(self.env)
             for event in att.get_timeline_events(req, db, 'wiki', format,
                                                  start, stop,
@@ -417,6 +418,8 @@
         req.hdf['wiki.history'] = history
 
     def _render_view(self, req, db, page):
+        req.perm.assert_permission('WIKI_VIEW')
+
         page_name = self._set_title(req, page, '')
         if page.name == 'WikiStart':
             req.hdf['title'] = ''
