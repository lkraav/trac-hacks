=== templates/macros.cs
==================================================================
--- templates/macros.cs	(/mirror/trac)	(revision 2508)
+++ templates/macros.cs	(/trac/workflow)	(local)
@@ -179,4 +179,26 @@
     var:href ?>&amp;order=<?cs var:class ?><?cs
     if:order == class && !desc ?>&amp;desc=1<?cs /if ?>"><?cs var:title ?></a>
  </th><?cs
+/def ?><?cs
+
+def:form_control(control) ?><?cs
+ if:control.label ?><label for="<?cs var:control.name ?>"><?cs var:control.label ?><?cs /if ?><?cs
+ if:control.type == "select" ?><?cs
+  call:hdf_select(control.options, control.name, control.value, control.optional) ?><?cs
+ elif:control.type == "text" ?>
+  <input type="text" id="<?cs var:control.name ?>" name="<?cs var:control.name ?>" size="<?cs alt:size ?>40<?cs /alt ?>" value="<?cs var:control.value ?>"><?cs
+ elif:control.type == "textarea" ?>
+  <textarea id="<?cs var:control.name ?>" name="<?cs var:control.name ?>" class="wikitext" rows="<?cs alt:rows ?>10<?cs /alt ?>" cols="<?cs alt:cols ?>78<?cs /alt ?>"><?cs var:control.value ?></textarea><?cs
+ elif:control.type == "checkbox" || control.type == "radio" ?>
+  <span id="<?cs var:control.name ?>"><?cs
+   each:option = control.options ?><?cs
+    if:!option.name ?><?cs
+     set:option.name = name(option) ?><?cs
+    /if ?>
+    <input type="<?cs var:control.type ?>" id="<?cs var:control.name ?>_<?cs var:option.name ?>" name="<?cs var:control.name ?>"<?cs if:option.checked ?> checked<?cs /if ?>>
+    <label for="<?cs var:control.name ?>_<?cs var:option.name ?>" ?><?cs alt:option.label ?><?cs var:option.value ?><?cs /alt ?></label><?cs
+   /each
+  ?></span><?cs
+ /if ?><?cs
+ if:control.label ?></label><?cs /if ?><?cs
 /def ?>
=== templates/ticket.cs
==================================================================
--- templates/ticket.cs	(/mirror/trac)	(revision 2508)
+++ templates/ticket.cs	(/trac/workflow)	(local)
@@ -227,8 +227,7 @@
   </table>
  </fieldset><?cs /if ?>
 
- <?cs if:ticket.actions.accept || ticket.actions.reopen ||
-         ticket.actions.resolve || ticket.actions.reassign ?>
+ <?cs if:ticket.actions.0.action ?>
  <fieldset id="action">
   <legend>Action</legend><?cs
   if:!ticket.action ?><?cs set:ticket.action = 'leave' ?><?cs
@@ -238,52 +237,47 @@
      var:id ?>"<?cs if:ticket.action == id ?> checked="checked"<?cs
      /if ?> /><?cs
   /def ?>
-  <?cs call:action_radio('leave') ?>
-   <label for="leave">leave as <?cs var:ticket.status ?></label><br /><?cs
-  if:ticket.actions.accept ?><?cs
-   call:action_radio('accept') ?>
-   <label for="accept">accept ticket</label><br /><?cs
-  /if ?><?cs
-  if:ticket.actions.reopen ?><?cs
-   call:action_radio('reopen') ?>
-   <label for="reopen">reopen ticket</label><br /><?cs
-  /if ?><?cs
-  if:ticket.actions.resolve ?><?cs
-   call:action_radio('resolve') ?>
-   <label for="resolve">resolve</label><?cs
-   if:len(ticket.fields.resolution.options) ?>
-    <label for="resolve_resolution">as:</label>
-    <?cs call:hdf_select(ticket.fields.resolution.options, "resolve_resolution",
-                         ticket.resolve_resolution, 0) ?><br /><?cs
-   /if ?><?cs
-  /if ?><?cs
-  if:ticket.actions.reassign ?><?cs
-   call:action_radio('reassign') ?>
-   <label for="reassign">reassign</label>
-   <label>to:<?cs
-   if:len(ticket.fields.owner.options) ?><?cs
-    call:hdf_select(ticket.fields.owner.options, "reassign_owner",
-                    ticket.reassign_owner, 1) ?><?cs
-   else ?>
-    <input type="text" id="reassign_owner" name="reassign_owner" size="40" value="<?cs
-      var:ticket.reassign_owner ?>" /><?cs
-   /if ?></label><?cs
-  /if ?><?cs
-  if ticket.actions.resolve || ticket.actions.reassign ?>
-   <script type="text/javascript"><?cs
-    each:action = ticket.actions ?>
-     var <?cs var:name(action) ?> = document.getElementById("<?cs var:name(action) ?>");<?cs
-    /each ?>
-     var updateActionFields = function() {
-       <?cs if:ticket.actions.resolve ?> enableControl('resolve_resolution', resolve.checked);<?cs /if ?>
-       <?cs if:ticket.actions.reassign ?> enableControl('reassign_owner', reassign.checked);<?cs /if ?>
-     };
-     addEvent(window, 'load', updateActionFields);<?cs
-     each:action = ticket.actions ?>
-      addEvent(<?cs var:name(action) ?>, 'click', updateActionFields);<?cs
-     /each ?>
-   </script><?cs
-  /if ?>
+
+  <script type="text/javascript">var action_controls = new Array();</script>
+
+  <?cs each:action = ticket.actions ?>
+   <script type="text/javascript">
+   action_controls['<?cs var:action.action ?>'] = new Array();
+   </script>
+			<?cs call:action_radio(action.action) ?>
+			<label for="<?cs var:action.action ?>"><?cs alt:action.label ?><?cs var:action.action ?><?cs /alt ?></label>
+   <?cs if:action.controls.0.name ?>
+    <span id="<?cs var:action.action ?>_controls">
+     <?cs each:control = action.controls ?>
+       <script type="text/javascript">action_controls['<?cs var:action.action ?>'].push('<?cs var:control.name ?>');</script>
+       <?cs call:form_control(control) ?>
+     <?cs /each ?>
+    </span>
+   <?cs /if ?>
+			<br />
+  <?cs /each ?>
+
+  <script type="text/javascript">
+   var action_control_elements = new Array();
+   for (var action in action_controls) {
+    action_control_elements[action] = document.getElementById(action);
+   }
+   var updateActionFields = function() {
+    for (var action in action_controls) {
+    var action_control = action_control_elements[action];
+
+     for (control in action_controls[action]) {
+      control = action_controls[action][control];
+      enableControl(control, action_control.checked);
+     }
+    }
+   }
+   addEvent(window, 'load', updateActionFields);
+   for (var action in action_controls) {
+   var action_control = action_control_elements[action];
+    addEvent(action_control, 'click', updateActionFields);
+   }
+  </script>
  </fieldset><?cs
  else ?>
   <input type="hidden" name="action" value="leave" /><?cs
=== trac/ticket/api.py
==================================================================
--- trac/ticket/api.py	(/mirror/trac)	(revision 2508)
+++ trac/ticket/api.py	(/trac/workflow)	(local)
@@ -19,15 +19,39 @@
 from trac.perm import IPermissionRequestor
 from trac.wiki import IWikiSyntaxProvider
 from trac.Search import ISearchSource, query_to_sql, shorten_result
+from trac.web import form
 
+class ITicketFieldController(Interface):
+    """ An interface for controlling what ticket fields can be viewed and changed. """
 
-class TicketSystem(Component):
-    implements(IPermissionRequestor, IWikiSyntaxProvider, ISearchSource)
+    def get_ticket_fields(req, ticket):
+        """ Return a list of fields available for a ticket. """
 
-    # Public API
+    def get_ticket_field_controls(req, ticket, field):
+        """ Return the HTML control for managing a ticket field. """
 
-    def get_available_actions(self, ticket, perm_):
-        """Returns the actions that can be performed on the ticket."""
+    def change_ticket_field(req, ticket, field):
+        """ Change a ticket field. """
+
+class ITicketActionController(Interface):
+    """ This interface controls what actions can be performed on a ticket. """
+    def get_ticket_actions(req, ticket):
+        """ Return the actions that are available given the current state of
+            ticket and the request object provided. """
+
+    def get_ticket_action_controls(req, ticket, action):
+        """ Return HTML control for performing action on ticket. """
+
+    def apply_ticket_action(req, ticket, action):
+        """ Perform action on ticket. """
+
+class DefaultTicketActionController(Component):
+    """ Default Trac implementation of ticket actions. """
+
+    implements(ITicketActionController)
+
+    # ITicketActionController methods
+    def get_ticket_actions(self, req, ticket):
         actions = {
             'new':      ['leave', 'resolve', 'reassign', 'accept'],
             'assigned': ['leave', 'resolve', 'reassign'          ],
@@ -37,8 +61,68 @@
         perms = {'resolve': 'TICKET_MODIFY', 'reassign': 'TICKET_CHGPROP',
                  'accept': 'TICKET_CHGPROP', 'reopen': 'TICKET_CREATE'}
         return [action for action in actions.get(ticket['status'], ['leave'])
-                if action not in perms or perm_.has_permission(perms[action])]
+                if action not in perms or req.perm.has_permission(perms[action])]
 
+    def get_ticket_action_controls(self, req, ticket, action):
+        from trac.ticket import model
+        controls = {
+            'leave': {
+                'label': 'leave as %s' % ticket['status'],
+            },
+            'resolve': form.Select('resolve_resolution',
+                                   options = [val.name for val in \
+                                              model.Resolution.select(self.env)],
+                                   label = 'as:',
+                                   value = req.args.get('resolve_resolution', '')),
+            'reassign': form.Text('reassign_owner',
+                                   value =req.args.get('reassign_owner', req.authname),
+                                   label ='to:'),
+            'accept': {
+                'label': 'accept ticket',
+            },
+            'reopen': {
+                'label': 'reopen ticket',
+            },
+        }
+        return controls[action]
+
+    def apply_ticket_action(self, req, ticket, action):
+        if action == 'accept':
+            ticket['status'] =  'assigned'
+            ticket['owner'] = req.authname
+        elif action == 'resolve':
+            ticket['status'] = 'closed'
+            ticket['resolution'] = req.args.get('resolve_resolution')
+        elif action == 'reassign':
+            ticket['owner'] = req.args.get('reassign_owner')
+            ticket['status'] = 'new'
+        elif action == 'reopen':
+            ticket['status'] = 'reopened'
+            ticket['resolution'] = ''
+        elif action != 'leave':
+            ticket['status'] = action
+
+
+class TicketSystem(Component):
+    implements(IPermissionRequestor, IWikiSyntaxProvider, ISearchSource)
+
+    action_controllers = ExtensionPoint(ITicketActionController)
+
+    # Public API
+
+    def _get_action_controller(self):
+        """ Get single action controller for ticket actions. """
+        controllers = list(self.action_controllers)
+        if len(controllers) != 1:
+            message = "Exactly one ITicketActionController must be active, " \
+                      "please disable all but one implementation. "
+            if len(controllers) > 1:
+                raise TracError(message + "Current controllers are %s." %
+                                ', '.join(map(repr, controllers)))
+            raise TracError(message + "No active implementations.")
+        return controllers[0]
+    action_controller = property(_get_action_controller)
+
     def get_ticket_fields(self):
         """Returns the list of fields available for tickets."""
         from trac.ticket import model
@@ -179,4 +263,4 @@
                    '#%d: %s' % (tid, util.shorten_line(summary)),
                    date, author,
                    shorten_result(desc, query.split()))
-            
+
=== trac/ticket/web_ui.py
==================================================================
--- trac/ticket/web_ui.py	(/mirror/trac)	(revision 2508)
+++ trac/ticket/web_ui.py	(/trac/workflow)	(local)
@@ -28,8 +28,8 @@
 from trac.web import IRequestHandler
 from trac.web.chrome import add_link, add_stylesheet, INavigationContributor
 from trac.wiki import wiki_to_html, wiki_to_oneliner
+from trac.web import form
 
-
 class NewticketModule(Component):
 
     implements(IEnvironmentSetupParticipant, INavigationContributor,
@@ -348,23 +348,12 @@
 
         # Do any action on the ticket?
         action = req.args.get('action')
-        actions = TicketSystem(self.env).get_available_actions(ticket, req.perm)
+        action_controller = TicketSystem(self.env).action_controller
+        actions = action_controller.get_ticket_actions(req, ticket)
         if action not in actions:
             raise TracError('Invalid action')
 
-        # TODO: this should not be hard-coded like this
-        if action == 'accept':
-            ticket['status'] =  'assigned'
-            ticket['owner'] = req.authname
-        if action == 'resolve':
-            ticket['status'] = 'closed'
-            ticket['resolution'] = req.args.get('resolve_resolution')
-        elif action == 'reassign':
-            ticket['owner'] = req.args.get('reassign_owner')
-            ticket['status'] = 'new'
-        elif action == 'reopen':
-            ticket['status'] = 'reopened'
-            ticket['resolution'] = ''
+        action_controller.apply_ticket_action(req, ticket, action)
 
         now = int(time.time())
         ticket.save_changes(req.args.get('author', req.authname),
@@ -445,6 +434,16 @@
                                                                      ticket.id)
 
         # Add the possible actions to hdf
-        actions = TicketSystem(self.env).get_available_actions(ticket, req.perm)
+        import types
+        action_controller = TicketSystem(self.env).action_controller
+        actions = action_controller.get_ticket_actions(req, ticket)
+        ticket_actions = []
         for action in actions:
-            req.hdf['ticket.actions.' + action] = '1'
+            controls = action_controller.get_ticket_action_controls(req, ticket, action)
+            if isinstance(controls, form.Control):
+                controls = {'controls': [controls]}
+            elif type(controls) is list:
+                controls = {'controls': controls}
+            controls['action'] = action
+            ticket_actions.append(controls)
+        req.hdf['ticket.actions'] = ticket_actions
=== trac/web/form.py
==================================================================
--- trac/web/form.py	(/mirror/trac)	(revision 2508)
+++ trac/web/form.py	(/trac/workflow)	(local)
@@ -0,0 +1,65 @@
+# -*- coding: iso-8859-1 -*-
+#
+# Copyright (C) 2005 Edgewall Software
+# Copyright (C) 2005 Alec Thomas <alec@swapoff.org>
+# All rights reserved.
+#   
+# This software is licensed as described in the file COPYING, which
+# you should have received as part of this distribution. The terms
+# are also available at http://trac.edgewall.com/license.html.
+#       
+# This software consists of voluntary contributions made by many
+# individuals. For the exact contribution history, see the revision
+# history and logs, available at http://projects.edgewall.com/trac/.
+#       
+# Author: Alec Thomas <alec@swapoff.org>
+
+"""
+Form control wrappers. Pass these as HDF elements to the ClearSilver
+form_control() macro to get generic form controls.
+
+    eg. hdf['form.name'] = form.Text('name', label = 'Username:')
+
+Then in your template:
+
+    <?cs include:"macros.cs" ?>
+    <?cs call:form_control(form.name) ?>
+"""
+
+__all__ = [ 'Control', 'Text', 'CheckBox', 'CheckBoxSet', 'RadioSet',
+            'RadioButton', 'TextArea', 'Select' ]
+
+class Control(dict):
+    """ Represents a form control. type is one of text, select, textarea,
+        checkbox, radio"""
+    def __init__(self, name, type, value = '', **kwargs):
+        self.update({'name': name, 'type': type, 'value': value})
+        self.update(kwargs)
+
+class Text(Control):
+    def __init__(self, name, **kwargs):
+        Control.__init__(self, name, 'text', **kwargs)
+
+class TextArea(Control):
+    def __init__(self, name, **kwargs):
+        Control.__init__(self, name, 'textarea', **kwargs)
+
+class CheckBox(Control):
+    def __init__(self, value, name = '', **kwargs):
+        Control.__init__(self, name, value = value, type = 'checkbox', **kwargs)
+
+class CheckBoxSet(Control):
+    def __init__(self, name, options, **kwargs):
+        Control.__init__(self, name, type = 'checkbox', options = options, **kwargs)
+
+class RadioButton(Control):
+    def __init__(self, name, **kwargs):
+        Control.__init__(self, name, type = 'radio', **kwargs)
+
+class RadioSet(Control):
+    def __init__(self, name, options, **kwargs):
+        Control.__init__(self, name, type = 'radio', options = options, **kwargs)
+
+class Select(Control):
+    def __init__(self, name, options, **kwargs):
+        Control.__init__(self, name, 'select', options = options, **kwargs)
